#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/Abelian_sandpile_model
#c# 2019-09-17 <RC
#p# OK

my @res;

# Implement the Abelian sandpile model also known as Bak–Tang–Wiesenfeld model. It's history, mathematical definition and properties can be found under it's wikipedia article.
# The task requires the creation of a 2D grid of arbitrary size on which "piles of sand" can be placed. Any "pile" that has 4 or more sand particles on it collapses, resulting in four particles being subtracted from the pile and distributed among it's neighbors.
# It is recommended to display the output in some kind of image format, as terminal emulators are usually too small to display images larger than a few dozen characters tall. As an example of how to accomplish this, see the Bitmap/Write a PPM file task.

use strict;
use warnings;

my ($high, $wide) = split ' ', qx(stty size);
my $mask = "\0" x $wide . ("\0" . "\177" x ($wide - 2) . "\0") x ($high - 5) .
  "\0" x $wide;
my $pile = $mask =~ s/\177/ rand() < 0.02 ? chr 64 + rand 20 : "\0" /ger;

for ( 1 .. 1e6 )
  {
  print "\e[H", $pile =~ tr/\0-\177/ 1-~/r, "\n$_";
  my $add = $pile =~ tr/\1-\177/\0\0\0\200/r; # set high bit for >=4
  $add =~ /\200/ or last;
  $pile =~ tr/\4-\177/\0-\173/; # subtract 4 if >=4
  for ("\0$add", "\0" x $wide . $add, substr($add, 1), substr $add, $wide)
    {
    $pile |= $_;
    $pile =~ tr/\200-\377/\1-\176/; # add one to each neighbor of >=4
    $pile &= $mask;
    }
  select undef, undef, undef, 0.1; # comment out for full speed
  }

exit;

#.say for @res;

#my $ref = q:to/END/;
#END

#use Test;
#my $ref = $*VM ~~ /jvm/ ?? $jvm !! $moar;
#is @res.join("\n"), chomp $ref;
