#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/Address_of_a_variable
#c# 2018-07-11 <RC
#p# OK

use warnings;
use strict;
use feature 'say';

my $result;

#To get the address, get the reference to a variable, and either stringify it, or use Scalar::Util's refaddr() to get just the address. Also see Devel::Peek.

use Scalar::Util qw(refaddr);
say refaddr(\my $v), "\n";  # 135691508
#Use Devel::Pointer::PP if you want to dereference a certain address in memory.
#Changing the address of a variable is not easily possible, but see perlapi. Wanting to go against the automatic memory management is a sign that this is only used to hack around the deficiencies of dafter languages. I can imagine address munging is commonly used to make variable aliasing possible, but Perl already has a higher level syntax for that.
#Simple reference (address) manipulation.

my $a = 12;
my $b = \$a; # get reference
$$b = $$b + 30; # access referenced value
say $a; # prints 42
$result .= "$a\n";

#Example how to make variable overlay.
my $a2 = 12;
our $b2; # you can overlay only global variables (this line is only for strictness)
*b2 = \$a2;
say $b2; # prints 12
$result .= "$b2\n";
$b2++;
say $a2; # prints 13
$result .= "$a2\n";

my $ref = <<EOD;
42
12
13
EOD

use Test::More;
is ($result, $ref);
done_testing();
