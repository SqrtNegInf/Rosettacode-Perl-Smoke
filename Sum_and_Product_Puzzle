#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/Sum_and_Product_Puzzle
#c# 2018-10-RC >RC
#p# BROKEN

use feature 'say';
use warnings;
#use strict 'vars';

use List::Util qw(none);
use Data::Dumper;
use Time::HiRes qw(sleep);

sub grep_unique {
    my($by, @list) = @_;
    my @seen;
    for (@list) { 
        my $x = &$by(@{$_});
        $seen[$x]= defined $seen[$x] ? 0 : join ' ', @{$_};
    }
    grep { $_ } @seen;
}

sub sums {
    my($n) = @_;
    my @sums;
    push @sums, [$_, $n - $_] for 2 .. int $n/2;
    @sums;
}

sub sum     { $_[0] + $_[1] }
sub product { $_[0] * $_[1] }

for $i (2..97) {
    push @all_pairs, map { [$i, $_] } $i+1..98
}

  
# Fact 1:
#%p_unique = map { ~$_ } grep_unique(\&product, @all_pairs);
@p_unique = grep_unique(\&product, @all_pairs);
%p_unique = map { $_ => 1 } @p_unique; 
say Dumper %p_unique; exit;
#@s_pairs = grep { none { $p_unique{~$_} for sums(sum $_) } } @all_pairs;
 
# Fact 2:
@p_pairs = grep_unique(\&product, @s_pairs);
 
# Fact 3:
@final_pairs = grep_unique(\&sum, @p_pairs);
 
say join ' :: ', @final_pairs; exit;
printf "X = %d, Y = %d\n", @final_pairs;

# X = 4, Y = 13

#is(@final-pairs, '4 13');
say $result; 
#say $result = join "\n", @res;
my $ref = <<'EOD';
EOD

use Test::More;
#is($result, '4 13');
#done_testing();

__END__

=={{header|Perl}}==
{{trans|Perl 6}}
<lang perl></lang>
{{out}}
<pre style="height:35ex"></pre>
