#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/N-queens_minimum_and_knights_and_bishops
#t# inprogress
#c# 2022-07-xx >RC
#p# OK
#n# where can we use the new true/false here?

use v5.36;
#builtin::true; builtin::false;
use Data::Printer;          # debug only

my @res;

my (@board, @diag1, @diag2, @diag1Lookup, @diag2Lookup, $n, $minCount, $layout);

my @pieces = <Q B K>;
my %limits = ( 'Q' =>    7,     'B' =>     7,     'K' =>    6    );
my %names  = ( 'Q' => 'Queens', 'B' => 'Bishops', 'K' =>'Knights');

sub isAttacked($piece, $row, $col) {
    if ($piece eq 'Q') { 
        for (0...$n-1) { return 1 if $board[$_][$col] || $board[$row][$_] }
        return 1 if $diag1Lookup[$diag1[$row][$col]] || 
                    $diag2Lookup[$diag2[$row][$col]]
    } elsif ($piece eq 'B') {
        return 1 if $diag1Lookup[$diag1[$row][$col]] || $diag2Lookup[$diag2[$$row][$col]]
    } else { # 'K'
        return 1 if (
            $board[$row][$col] or 
            $row+2 < $n && $col-1 >= 0 && $board[$row+2][$col-1] or
            $row-2 >= 0 && $col-1 >= 0 && $board[$row-2][$col-1] or
            $row+2 < $n && $col+1 < $n && $board[$row+2][$col+1] or
            $row-2 >= 0 && $col+1 < $n && $board[$row-2][$col+1] or
            $row+1 < $n && $col+2 < $n && $board[$row+1][$col+2] or
            $row-1 >= 0 && $col+2 < $n && $board[$row-1][$col+2] or
            $row+1 < $n && $col-2 >= 0 && $board[$row+1][$col-2] or
            $row-1 >= 0 && $col-2 >= 0 && $board[$row-1][$col-2]
        )
   }
   return 0
}

sub attacks($piece, $row, $col, $trow, $tcol) {
   if    ($piece eq 'Q') { $row==$trow || $col==$tcol || abs($row - $trow)==abs($col - $tcol) } 
   elsif ($piece eq 'B') { abs($row - $trow) == abs($col - $tcol) }
   else                  { 
        my ($rd, $cd) = (abs($trow - $row), abs($tcol - $col));
        ($rd == 1 && $cd == 2) || ($rd == 2 && $cd == 1)
    }
}

sub storeLayout($piece) {
    $layout = '';
    for (@board) {
        map { $layout .= $_ ?  $piece.' ' : '. ' } @$_;
        $layout .=  "\n";
    }
}

# move placePiece here


for my $piece (@pieces) {
   push @res, $names{$piece} . "\n=======\n";
   for ($n = 1 ; ; $n++) {
      @board = map { [ (0) x $n ] } 1..$n;
      unless ($piece eq 'K') {
          @diag2 = reverse @diag1 = map { $_ .. $n+$_-1 } 0..$n-1;
	      @diag2Lookup = @diag1Lookup = [ (0) x 2*$n-1 ]
      }
      $minCount = 2**31 - 1;
      my $nSQ   = $n**2;
      for my $maxCount (1..$nSQ) {
         #placePiece($piece, 0, $maxCount);
         last if $minCount <= $nSQ 
      }
      push @res, sprintf("%2d x %-2d : %d", $n, $n, $minCount);
      if ($n == $limits{$piece}) {
         push @res, sprintf "\n%s on a %d x %d board:", $names{$piece}, $n, $n;
         push @res, $layout and last
      }
   }
}

__END__

sub placePiece($piece, $countSoFar, $maxCount) {
   return if $countSoFar >= $minCount; 
   my ($allAttacked,$ti,$tj) = true,0,0;
   for ^$n X ^$n -> ($i,$j) { 
      unless isAttacked($piece, $i, $j) {
         ($allAttacked,$ti,$tj) = 0,$i,$j andthen last
      }
      last unless $allAttacked 
   }
   if $allAttacked {
      $minCount = $countSoFar;
      storeLayout($piece);
      return
   }
   if countSoFar <= maxCount {
      my ($si,$sj) = $ti,$tj;
      if piece eq 'K' {
         ($si,$sj) >>-=>> 2;
         $si = 0 if $si < 0; 
         $sj = 0 if $sj < 0; 
      }
      for ($si..^$n) X ($sj..^$n) -> ($i,$j) {
         unless isAttacked($piece, $i, $j) {
            if ($i == $ti && $j == $tj) || attacks($piece, $i, $j, $ti, $tj) {
               @board[i][j] = 1; 
               unless $piece eq 'K' {
	          (@diag1Lookup[@diag1[$i;$j]],@diag2Lookup[@diag2[$i;$j]])=1 xx *               
               }
               placePiece($piece, $countSoFar+1, $maxCount);
               @board[$i][$j] = 0; 
               unless $piece eq 'K' {
                  (@diag1Lookup[@diag1[$i;$j]],@diag2Lookup[@diag2[$i;$j]])=0 xx *
               }
            }
	 }
      }
   }
}

say my $result = join "\n", @res;

my $ref = <<'END';
Queens
=======

 1 x 1  : 1
 2 x 2  : 1
 3 x 3  : 1
 4 x 4  : 3
 5 x 5  : 3
 6 x 6  : 4
 7 x 7  : 4

Queens on a 7 x 7 board:
.  Q  .  .  .  .  . 
.  .  .  .  .  Q  . 
.  .  .  .  .  .  . 
Q  .  .  .  .  .  . 
.  .  .  .  Q  .  . 
.  .  .  .  .  .  . 
.  .  .  .  .  .  . 

Bishops
=======

 1 x 1  : 1
 2 x 2  : 2
 3 x 3  : 3
 4 x 4  : 4
 5 x 5  : 5
 6 x 6  : 6
 7 x 7  : 7

Bishops on a 7 x 7 board:
.  .  .  .  .  B  . 
.  .  B  .  .  .  . 
.  .  B  .  B  .  . 
.  .  .  .  .  .  B 
.  .  .  B  .  .  . 
.  .  .  B  .  .  . 
.  .  .  .  .  .  . 

Knights
=======

 1 x 1  : 1
 2 x 2  : 4
 3 x 3  : 4
 4 x 4  : 4
 5 x 5  : 5
 6 x 6  : 8

Knights on a 6 x 6 board:
K  .  .  .  .  K 
.  .  .  .  .  . 
.  .  K  K  .  . 
.  .  K  K  .  . 
.  .  .  .  .  . 
K  .  .  .  .  K 

END

use Test::More;
chomp $ref;
is($result, $ref);
done_testing();

__END__

=={{header|Perl}}==
{{trans|Raku}}
<lang perl>
</lang>
{{out}}
<pre>
</pre>
