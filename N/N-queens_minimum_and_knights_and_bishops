#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/N-queens_minimum_and_knights_and_bishops
#t# inprogress
#c# 2022-07-xx >RC
#p# OK
#n# where can we use the new true/false here?

use v5.36;
use builtin 'true', 'false';
no warnings 'experimental::for_list', 'experimental::builtin';

use Data::Printer;          # debug only

my @res;

my (@board, @diag1, @diag2, @diag1Lookup, @diag2Lookup, $n, $minCount, $layout);

my @pieces = <Q B K>;
my %limits = ( 'Q' =>    7,     'B' =>     7,     'K' =>    6    );
my %names  = ( 'Q' => 'Queens', 'B' => 'Bishops', 'K' =>'Knights');

sub isAttacked($piece, $row, $col) {
    if ($piece eq 'Q') { 
        for (0...$n-1) { return 1 if $board[$_][$col] || $board[$row][$_] }
        return true if $diag1Lookup[$diag1[$row][$col]] || 
                    $diag2Lookup[$diag2[$row][$col]]
    } elsif ($piece eq 'B') {
        return true if $diag1Lookup[$diag1[$row][$col]] || $diag2Lookup[$diag2[$$row][$col]]
    } else { # 'K'
        return true if (
            $board[$row][$col] or 
            $row+2 < $n && $col-1 >= 0 && $board[$row+2][$col-1] or
            $row-2 >= 0 && $col-1 >= 0 && $board[$row-2][$col-1] or
            $row+2 < $n && $col+1 < $n && $board[$row+2][$col+1] or
            $row-2 >= 0 && $col+1 < $n && $board[$row-2][$col+1] or
            $row+1 < $n && $col+2 < $n && $board[$row+1][$col+2] or
            $row-1 >= 0 && $col+2 < $n && $board[$row-1][$col+2] or
            $row+1 < $n && $col-2 >= 0 && $board[$row+1][$col-2] or
            $row-1 >= 0 && $col-2 >= 0 && $board[$row-1][$col-2]
        )
   }
   false
}

sub attacks($piece, $row, $col, $trow, $tcol) {
   if    ($piece eq 'Q') { $row==$trow || $col==$tcol || abs($row - $trow)==abs($col - $tcol) } 
   elsif ($piece eq 'B') { abs($row - $trow) == abs($col - $tcol) }
   else                  { 
        my ($rd, $cd) = (abs($trow - $row), abs($tcol - $col));
        ($rd == 1 && $cd == 2) || ($rd == 2 && $cd == 1)
    }
}

sub storeLayout($piece) {
    $layout = '';
    for (@board) {
        map { $layout .= $_ ?  $piece.' ' : '. ' } @$_;
        $layout .=  "\n";
    }
}

sub X ($a,$b)       { my @c; for my $aa (0..$a)  { for my $bb (0..$b)  { push @c, $aa, $bb } } @c }
sub Xr($a,$b,$c,$d) { my @c; for my $ab ($a..$b) { for my $cd ($c..$d) { push @c, $ab, $cd } } @c }

sub placePiece($piece, $countSoFar, $maxCount) {
   return if $countSoFar >= $minCount; 
   my ($allAttacked,$ti,$tj) = (true,0,0);
   for my($i,$j) (X $n $n) {
      unless (isAttacked($piece, $i, $j)) {
         ($allAttacked,$ti,$tj) = (false,$i,$j) and last
      }
      last unless $allAttacked 
   }
   if ($allAttacked) {
      $minCount = $countSoFar;
      storeLayout($piece);
      return
   }
   if ($countSoFar <= $maxCount) {
      my ($si,$sj) = ($ti,$tj);
      if ($piece eq 'K') {
         $si -= 2; $si = 0 if $si < 0; 
         $sj -= 2; $sj = 0 if $sj < 0; 
      }
      for my ($i,$j) (Xr $si,$n-1,$sj,$n-1) {
         unless (isAttacked($piece, $i, $j)) {
            if (($i == $ti && $j == $tj) || attacks($piece, $i, $j, $ti, $tj)) {
               $board[$i][$j] = true; 
               unless ($piece eq 'K') {
	          ($diag1Lookup[$diag1[$i][$j]], $diag2Lookup[$diag2[$i][$j]]) = (true,true);
               };
               placePiece($piece, $countSoFar+1, $maxCount);
               $board[$i][$j] = false; 
               unless ($piece eq 'K') {
                  ($diag1Lookup[$diag1[$i][$j]],$diag2Lookup[$diag2[$i][$j]]) = (false,false);
               }
            }
	 }
      }
   }
}


for my $piece (@pieces) {
   push @res, $names{$piece} . "\n=======\n";
   for ($n = 1 ; ; $n++) {
      @board = map { [ (false) x $n ] } 1..$n;
      unless ($piece eq 'K') {
          @diag2 = reverse @diag1 = map { $_ .. $n+$_-1 } 0..$n-1;
	      @diag2Lookup = @diag1Lookup = [ (false) x 2*$n-1 ]
      }
      $minCount = 2**31 - 1;
      my $nSQ   = $n**2;
      for my $maxCount (1..$nSQ) {
         placePiece($piece, 0, $maxCount);
         last if $minCount <= $nSQ 
      }
      push @res, sprintf("%2d x %-2d : %d", $n, $n, $minCount);
      if ($n == $limits{$piece}) {
         push @res, sprintf "\n%s on a %d x %d board:", $names{$piece}, $n, $n;
         push @res, $layout and last
      }
   }
}

__END__

say my $result = join "\n", @res;

my $ref = <<'END';
Queens
=======

 1 x 1  : 1
 2 x 2  : 1
 3 x 3  : 1
 4 x 4  : 3
 5 x 5  : 3
 6 x 6  : 4
 7 x 7  : 4

Queens on a 7 x 7 board:
.  Q  .  .  .  .  . 
.  .  .  .  .  Q  . 
.  .  .  .  .  .  . 
Q  .  .  .  .  .  . 
.  .  .  .  Q  .  . 
.  .  .  .  .  .  . 
.  .  .  .  .  .  . 

Bishops
=======

 1 x 1  : 1
 2 x 2  : 2
 3 x 3  : 3
 4 x 4  : 4
 5 x 5  : 5
 6 x 6  : 6
 7 x 7  : 7

Bishops on a 7 x 7 board:
.  .  .  .  .  B  . 
.  .  B  .  .  .  . 
.  .  B  .  B  .  . 
.  .  .  .  .  .  B 
.  .  .  B  .  .  . 
.  .  .  B  .  .  . 
.  .  .  .  .  .  . 

Knights
=======

 1 x 1  : 1
 2 x 2  : 4
 3 x 3  : 4
 4 x 4  : 4
 5 x 5  : 5
 6 x 6  : 8

Knights on a 6 x 6 board:
K  .  .  .  .  K 
.  .  .  .  .  . 
.  .  K  K  .  . 
.  .  K  K  .  . 
.  .  .  .  .  . 
K  .  .  .  .  K 

END

use Test::More;
chomp $ref;
is($result, $ref);
done_testing();

__END__

=={{header|Perl}}==
{{trans|Raku}}
<lang perl>
</lang>
{{out}}
<pre>
</pre>
