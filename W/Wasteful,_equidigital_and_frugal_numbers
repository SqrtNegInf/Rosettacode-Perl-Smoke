#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/Wasteful,_equidigital_and_frugal_numbers
#c# 2022-07-21 >RC
#p# OK
#n# 'todigitstring' is much faster than pure-Perl version

my @res;

use v5.36;
use experimental 'for_list';

use ntheory <factor todigitstring>;
use List::Util <sum max min pairmap>;

sub table ($c, @V) { my $t = $c * (my $w = 6); ( sprintf( ('%'.$w.'d')x@V, @V) ) =~ s/.{1,$t}\K/\n/gr }

sub bag (@v) { my %h; $h{$_}++ for @v; %h }

for my $base (10, 11) {
    my(@F,@E,@W,$n,$totals);
    do {
        my %F = bag factor ++$n;
        my $s = sum pairmap { length(todigitstring($a,$base)) + ($b > 1 ? length(todigitstring($b,$base)) : 0) } %F;
        my $l = length todigitstring($n,$base);
        if    ($n == 1 or $l == $s) { push @E, $n }
        elsif (           $l <  $s) { push @W, $n }
        else                        { push @F, $n }
    } until 10000 < min scalar @F, scalar @E, scalar @W;
    
    push @res, "In base $base:";
    for my ($type, $values) ('Wasteful', \@W, 'Equidigital', \@E, 'Frugal', \@F) {
        push @res, "\n$type numbers:"; 
        push @res, table 10, @$values[0..49]; 
        push @res, "10,000th: $$values[9999]";
        $totals .= sprintf "%11s: %d\n", $type, scalar grep { $_ < 1_000_000 } @$values
    }
    push @res, "\nOf the positive integers up to ten thousand:\n$totals";
}

say my $result = join "\n", @res;

my $ref = <<'END';
In base 10:

Wasteful numbers:
     4     6     8     9    12    18    20    22    24    26
    28    30    33    34    36    38    39    40    42    44
    45    46    48    50    51    52    54    55    56    57
    58    60    62    63    65    66    68    69    70    72
    74    75    76    77    78    80    82    84    85    86

10,000th: 14346

Equidigital numbers:
     1     2     3     5     7    10    11    13    14    15
    16    17    19    21    23    25    27    29    31    32
    35    37    41    43    47    49    53    59    61    64
    67    71    73    79    81    83    89    97   101   103
   105   106   107   109   111   112   113   115   118   119

10,000th: 33769

Frugal numbers:
   125   128   243   256   343   512   625   729  1024  1029
  1215  1250  1280  1331  1369  1458  1536  1681  1701  1715
  1792  1849  1875  2048  2187  2197  2209  2401  2560  2809
  3125  3481  3584  3645  3721  4096  4374  4375  4489  4802
  4913  5041  5103  5329  6241  6250  6561  6859  6889  7203

10,000th: 1953125

Of the positive integers up to ten thousand:
   Wasteful: 831231
Equidigital: 165645
     Frugal: 3123

In base 11:

Wasteful numbers:
     4     6     8     9    10    12    18    20    22    24
    26    28    30    33    34    36    38    39    40    42
    44    45    46    48    50    51    52    54    55    56
    57    58    60    62    63    65    66    68    69    70
    72    74    75    76    77    78    80    82    84    85

10,000th: 12890

Equidigital numbers:
     1     2     3     5     7    11    13    14    15    16
    17    19    21    23    25    27    29    31    32    35
    37    41    43    47    49    53    59    61    64    67
    71    73    79    81    83    89    97   101   103   107
   109   113   121   122   123   127   129   131   133   134

10,000th: 33203

Frugal numbers:
   125   128   243   256   343   512   625   729  1024  1331
  1369  1458  1536  1681  1701  1715  1792  1849  1875  2048
  2187  2197  2209  2401  2560  2809  3072  3125  3481  3584
  3645  3721  4096  4374  4375  4489  4802  4913  5041  5103
  5120  5329  6241  6250  6561  6859  6889  7168  7203  7921

10,000th: 2659171

Of the positive integers up to ten thousand:
   Wasteful: 795861
Equidigital: 200710
     Frugal: 3428

END

use Test::More;
is(($result =~ s/\s//gr), ($ref =~ s/\s//gr));
done_testing;
