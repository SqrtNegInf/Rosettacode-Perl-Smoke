#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/Word_search
#c# 2019-12-19 <RC
#p# OK

use strict;
use warnings;
use feature 'say';

my @res;

srand 123456;

use Path::Tiny;
use List::Util qw( shuffle );

my $size = 10;
my $s1 = $size + 1;
$_ = <<END;
.....R....
......O...
.......S..
........E.
T........T
.A........
..C.......
...O......
....D.....
.....E....
END

my @words = shuffle path('/usr/share/dict/words')->slurp =~ /^[a-z]{3,7}$/gm;
my @played;
my %used;

for my $word ( (@words) x 5 )
  {
  my ($pat, $start, $end, $mask, $nulls) = find( $word );
  defined $pat or next;
  $used{$word}++ and next; # only use words once
  $nulls //= '';
  my $expand = $word =~ s/\B/$nulls/gr;
  my $pos = $start;
  if( $start > $end )
    {
    $pos = $end;
    $expand = reverse $expand;
    }
  substr $_, $pos, length $mask,
    (substr( $_, $pos, length $mask ) & ~ "$mask") | "$expand";
  push @played, join ' ', $word, $start, $end;
  tr/.// > 0 or last;
  }

push @res, "   0 1 2 3 4 5 6 7 8 9\n\n";
my $row = 0;
push @res, s/(?<=.)(?=.)/ /gr =~ s/^/ $row++ . '  ' /gemr;
push @res, "\nNumber of words: " . @played . "\n\n";
my @where = map
  {
  my ($word, $start, $end) = split;
  sprintf "%11s %s", $word, $start < $end
    ? "(@{[$start % $s1    ]}, @{[int $start / $s1]})->" .
      "(@{[$end   % $s1 - 1]}, @{[int $end   / $s1]})"
    : "(@{[$start % $s1 - 1]}, @{[int $start / $s1]})->" .
      "(@{[$end   % $s1    ]}, @{[int $end   / $s1]})";
  } sort @played;

push @res, join(' ', splice(@where, 0, 3)) while @where;
tr/.// and die "incomplete";

sub find
  {
  my ($word) = @_;
  my $n = length $word;
  my $nm1 = $n - 1;
  my %pats;

  for my $space ( 0, $size - 1 .. $size + 1 )
    {
    my $nulls = "\0" x $space;
    my $mask = "\xff" . ($nulls . "\xff") x $nm1; # vert
    my $gap = qr/.{$space}/s;
    while( /(?=(.(?:$gap.){$nm1}))/g )
      {
      my $pat = ($1 & $mask) =~ tr/\0//dr;
      $pat =~ tr/.// or next;
      my $pos = "$-[1] $+[1]";
      $word =~ /$pat/ or reverse($word) =~ /$pat/ or next;
      push @{ $pats{$pat} }, "$pos $mask $nulls";
      }
    }

  for my $key ( sort keys %pats )
    {
    if( $word =~ /^$key$/ )
      {
      my @all = @{ $pats{$key} };
      return $key, split ' ', $all[ rand @all ];
      }
    elsif( (reverse $word) =~ /^$key$/ )
      {
      my @all = @{ $pats{$key} };
      my @parts = split ' ', $all[ rand @all ];
      return $key, @parts[ 1, 0, 2, 3]
      }
    }

  return undef;
  }

say my $result = join "\n", @res;

my $ref = <<'EOD';
   0 1 2 3 4 5 6 7 8 9


0  s x a s g R g n t h
1  l k r n a u O h n a
2  g a i m n l i S a l
3  s o u d a u p n E t
4  T h u n w n l o e T
5  d A a g k a d l i a
6  o p C m e n y a a d
7  w o l O a r o r t h
8  d u m i D n e w e e
9  y g n u m E v e n d


Number of words: 24


        alt (9, 1)->(9, 3)       annul (2, 0)->(6, 4)         ant (8, 2)->(8, 0)
      dowdy (0, 5)->(0, 9)         dum (0, 8)->(2, 8)         ere (4, 6)->(6, 8)
       ghat (6, 0)->(9, 3)      gouger (0, 2)->(5, 7)      guinea (4, 0)->(9, 5)
       laun (0, 1)->(3, 4)         low (2, 7)->(0, 7)     mandate (3, 2)->(9, 8)
      mungy (4, 9)->(0, 9)         nth (7, 0)->(9, 0)      nullah (4, 2)->(9, 7)
       plim (1, 6)->(4, 9)         ras (2, 1)->(0, 3)         red (7, 7)->(9, 9)
    salpoid (3, 0)->(9, 6)         sax (3, 0)->(1, 0)      shaman (0, 3)->(5, 8)
    skidway (0, 0)->(6, 6)     unknown (2, 3)->(8, 9)        vend (6, 9)->(9, 9)
EOD

use Test::More;
chomp $ref;
is ($result, $ref);
done_testing();
