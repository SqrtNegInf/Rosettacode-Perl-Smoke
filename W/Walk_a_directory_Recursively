#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/Walk_a_directory/Recursively
#c# 2018-08-03 <>RC, 2021-11-15 <RC
#p# OK

use strict;
use warnings;
use feature 'say';

my($result1,$result2,$result3);

# Use the File::Find module from CPAN:

# Works with: Perl version 5.x
use File::Find qw(find);
my $dir      = 'ref/test';
my $pattern  = 'txt';
my $callback = sub { $result1 .= $File::Find::name. "\n" if /$pattern/ };
find $callback, $dir;

#Or if you need maximum performance and are on a 'nix system, open a pipe to the GNU find program:

sub shellquote { "'".(shift =~ s/'/'\\''/gr). "'" }

sub find_files {
    my $dir = shellquote(shift);
    my $test = shellquote(shift);

    local $/ = "\0";
    open my $pipe, "find $dir -iname $test -print0 |" or die "find: $!.\n";
    while (<$pipe>) { chop $_; $result2 .= "$_\n"; }
    close $pipe;
}

find_files('ref/test', '*txt');

# 2021-11-15 Tybalt89 adds:
use Path::Tiny;
path('ref/test')->visit( sub {/\.txt$/ and $result3 .= "$_\n"}, {recurse => 1} );

say $result1;

my $ref1 = <<'EOD';
ref/test/not-in-kansas.txt
ref/test/reverse_words.txt
ref/test/sample.txt
ref/test/dir1/not-in-kansas.txt
ref/test/dir2/sample.txt
EOD

my $ref2 = <<'EOD';
ref/test/dir1/not-in-kansas.txt
ref/test/dir2/sample.txt
ref/test/not-in-kansas.txt
ref/test/reverse_words.txt
ref/test/sample.txt
EOD

use Test::More;
is ($result1, $ref1);
is ($result2, $ref2);
is ($result3, $ref1);
done_testing();
