WIP: Ways that Perl can provide similar/approx functionality as Raku built-ins

Notes
=====

For many of the math/numeric entries, Math::AnyNum is oftenn an option, but 
typically list a more narrowly targeted module (reflects usage in RC tasks)

Some modules referenced are core, most are not.

For the List::* suite of modules, give priorit to List::Util, otherwise reference
List::AllUtils (unless routine only found elsewhere, e.g. List::MoreUtils).

Pragmas
=======

==> modern-ish Perl

# in v5.36 these come 'for free'
P6 say / state
P5 use feature <say state>  

P6 large values/extended precision (*.FatRat)
P5 bigint / bigrat / bignum

P6 "subroutine signatures"
P5 use experimental 'signatures'

P6 "display non-ASCII text"
P5 use utf8; binmode STDOUT, ":encoding(UTF-8)";

==> v5.36 and up only

P6    *.floor
P5.36 use builtin 'floor';

P6    for * -> $i, $j {
P5.36 use experimental 'for_list';

P6    @*.kv
P5.36 use builtin 'indexed'


Modules
=======

Special mention:

P6 [<op>]
P5 List::Util::reduce 

P6 [\<op>]
P5 List::Util::reductions

-----

P6 X  
P5 ntheory 'forsetproduct'
P5 Set::Product 'product'
P5 Math::Cartesian::Product 'cartesian'

P6 Z  
P5 List::Util 'mesh'                # aka 'zip'

P6 .rotor(2 => -1)
P5 List::MoreUtils 'slide'          # as a filter
P5 List::MoreUtils 'slideatatime'   # as an iterator, e.g. slideatatime(1, 2, @a)

P6 classify
P5 List::Categorize 'categorize'

P6 is-prime / gcd
P5 ntheory <is_prime gcd>

P6 [+]                              # aka 'sum'
P5 List::Util <sum sum0>
P5 ntheory <vecsum>

P6 [√ó]
P5 List::Util 'product'
P5 ntheory 'vecprod'

P6 pick(*)
P5 List::Util 'shuffle'

P6 grep(*, :k)
P5 List::AllUtils <indexes>

P6 first / first(*, :k)
P5 List::Util <first firstidx>
P5 ntheory <vecfirst vecfirstidx>

P6 last / last(*, :k)
P5 List::MoreUtils <last lastidx>

P6 min / max 
P5 List::Util <min max minstr maxstr>

# nb: tread carefully here, int/frac portions, sign 
P6 %%
P5 POSIX 'fmod'
P5 Math::ModInt 'mod'
P5 Math::AnyNum 'imod'

# cf 'floor' pragma
P6 floor
P5 POSIX 'floor'

P6 ceiling
P5 POSIX 'ceil'

P6 *.log(10)
P5 POSIX 'log10'

P6 unique
P5 List::Util 'uniq' # aka 'distinct'

# cf 'for_list' pragma
P6 for * -> $i, $j {
P5 List:AllUtils 'natatime';

P6 sleep
P5 Time::HiRes 'sleep'

P6 combinations
P5 Algorithm::Combinatorics 'combinations'

P6 permutations
P5 Algorithm::Permute                       # iterator
P5 ntheory 'forperm'                        #    "
P5 Algorithm::Combinatorics <permutations tuples_with_repetition>

P6 head / tail
P5 List::Util <head tail>

P6 polymod
P5 Math::AnyNum 'polymod'

P6 round
P5 Math::AnyNum 'round'

P6 div
P5 Math::AnyNum 'idiv'

# not a simple one-to-one mapping here, diverse applications
P6 base (and polymode)
P5 ntheory <fromdigits todigitstring todigits>;

P6 any / all / none
P5 List::Util <any all none>
P5 Quantum::Superpositions

P6 "laziness"                   # very broadly applied
P5 List::Lazy 'lazy_list'       # very narrowly implemented
P5 List::Lazy 'lazy_range'      #           "

P6 "complex arithmetic"
P5 Math::Complex
P5 Math::AnyNum

P6 "trig functions"
P5 Math::Trig

# cf bigint / bigrat / bigfloat, which differ in having wider scope (among other things)
P6 large values/extended precision (*.FatRat)
P5 Math::BigInt / Math::BigRat / Math::BigFloat

P6 Inf
P5 Math::AnyNum 'Inf'

P6 œÄ
P5 Math::AnyNum 'pi'

P6 ùëí
P5 Math::AnyNum 'e'
P5 bignum <e>;

P6 *.uniname / *.uniprops
P5 Unicode::UCD <charinfo charprop>

P6 "Unicode normalized form"
P5 Unicode::Normalize <NFC NFD>

P6 $*TOLERANCE
P5 Test::Number::Delta

P6 minmax
P5 List::AllUtils 'minmax'

P6 "concurrency"
P5 Parallel::ForkManager

P6 "sets"
P5 Set::Object

P6 "bags"
P5 Set::Bag
P5 List::MoreUtils 'frequency'

# a bit tenuous?
P6 "is cached"
P5 Memoize

# C/Currency, G/Generalised_floating_point_addition
P6 "arithmetic with rationals"
P5 Math::Decimal <dec_add dec_mul_pow10>

P6
P5

P6
P5

P6
P5

P6
P5

P6
P5

P6
P5

P6
P5

