WIP: Way that Perl can provide similar/approx functionality as Raku built-ins

Pragmas
=======

==> modern-ish Perl

P6 say state
P5 use feature <say state>  

==> v5.36 and up only

P6    say state
P5.36 say state

P6    floor
P5.36 use builtin 'floor';

P6    for * -> $i, $j {
P5.36 use experimental 'for_list';


Modules
=======

Special mention:

P6 [<op>]
P5 List::Util::reduce 

P6 [\<op>]
P5 List::Util::reductions

-----

P6 X  
P5 ?

P6 Z  
P5 List::Util 'mesh' # aka 'zip'

P6 .rotor(2 => -1)
P5 List::MoreUtils 'slide'        # as a filter
P5 List::MoreUtils 'slideatatime' # as an iterator

P6 classify
P5 List::Categorize 'categorize'

P6 is-prime / gcd
P5 ntheory <is_prime gcd>

P6 [+]                      # aka 'sum'
P5 List::Util <sum sum0>
P5 ntheory <vecsum>

P6 [Ã—]
P5 List::Util 'product'
P5 ntheory 'vecprod'

P6 pick(*)
P5 List::Util 'shuffle'

P6 grep(*, :k)
P5 List::AllUtils <indexes>

P6 first / first(*, :k)
P5 List::Util <first firstidx>
P5 ntheory <vecfirst vecfirstidx>

P6 min / max 
P5 List::Util <min max minstr maxstr>

# nb: tread carefully here, int/frac portions, sign 
P6 %%
P5 POSIX 'fmod'
P5 Math::ModInt 'mod'
P5 Math::AnyNum 'imod'

# cf 'floor' pragma
P6 floor
P5 POSIX 'floor'

P6 ceiling
P5 POSIX 'ceil'

P6 *.log(10)
P5 POSIX 'log10'

P6 unique
P5 List::Util 'uniq' # aka 'distinct'

# cf 'for_list' pragma
P6 for * -> $i, $j {
P5 List:AllUtils 'natatime';

P6 sleep
P5 Time::HiRes 'sleep'

P6 combinations
P5 Algorithm::Combinatorics 'combinations'

P6 head / tail
P5 List::Util <head tail>

P6 polymod
P5 Math::AnyNum 'polymod'

P6 round
P5 Math::AnyNum 'round'

P6 div
P5 Math::AnyNum 'idiv'

P6
P5

P6
P5

P6
P5

P6
P5

P6
P5

P6
P5

P6
P5

P6
P5

P6
P5

P6
P5

P6
P5

