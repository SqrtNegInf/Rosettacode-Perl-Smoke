#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/RC_REMOTE
#c# 2019-03-RC >RC
#p# OK

use Data::Printer;

use strict; # 'vars';
use warnings;
use feature 'say';
#my $result;
#my @res;

use List::Util 'max';

sub gauss {
    my(@m) = @_;

    for my $i (keys @m) {
        # swap rows - not needed?
        #my \k = max |(i .. @m.end), :by({ @m[$_][i].abs });
        #@m[i, k] .= reverse if \k != i;

        #.[i ^.. *] »/=» .[i] given @m[i];
 
        for my $j ($i+1 .. $#m) {
            #@m[j][i ^.. *] »-=« ( @m[j][i] «*« @m[i][i ^.. *] );
        }
    }
return;
    for my $i (reverse keys @m) {
        #@m[^i]».[*-1] »-=« ( @m[^i]».[i] »*» @m[i][*-1] );
    }
    #return @m».[*-1]; # last column
}

sub network {
    my($n,$k0,$k1,$grid) = @_;
    my @m;
    push @m, [(0)x($n+1)] for 1..$n;
 
    for my $resistor (split '\|', $grid) {
        #my ($a,$b,$r_inv) = grep { defined $_ } split /\s+/, $resistor; # don't need grep?
        my ($a,$b,$r_inv) = split /\s+/, $resistor;
        my $r = 1 / $r_inv;
 
        $m[$a][$a] += $r;
        $m[$b][$b] += $r;
        $m[$a][$b] -= $r if $a > 0;
        $m[$b][$a] -= $r if $b > 0;
    }
    $m[$k0][$k0] = 1;
    $m[$k1][ -1] = 1;
    return (gauss(@m))[$k1];
}

network(7, 0,     1, '0 2 6|2 3 4|3 4 10|4 5 2|5 6 8|6 1 4|3 5 6|3 6 6|3 1 8|2 1 8'); exit;

use Test::More;
my @tests = (
    [   10,   7, 0,     1, '0 2 6|2 3 4|3 4 10|4 5 2|5 6 8|6 1 4|3 5 6|3 6 6|3 1 8|2 1 8' ],
    [  3/2, 3*3, 0, 3*3-1, '0 1 1|1 2 1|3 4 1|4 5 1|6 7 1|7 8 1|0 3 1|3 6 1|1 4 1|4 7 1|2 5 1|5 8 1' ],
    [ 13/7, 4*4, 0, 4*4-1, '0 1 1|1 2 1|2 3 1|4 5 1|5 6 1|6 7 1|8 9 1|9 10 1|10 11 1|12 13 1|13 14 1|14 15 1|0 4 1|4 8 1|8 12 1|1 5 1|5 9 1|9 13 1|2 6 1|6 10 1|10 14 1|3 7 1|7 11 1|11 15 1' ],
    [  180,   4, 0,     3, '0 1 150|0 2 50|1 3 300|2 3 250' ],
);
#is(.[0], network( |.[1..4] ), .[4].substr(0,10)~'…') for @tests;
done_testing();

__END__

=={{header|Perl}}==
{{trans|Perl 6}}
<lang perl></lang>
{{out}}
<pre></pre>
