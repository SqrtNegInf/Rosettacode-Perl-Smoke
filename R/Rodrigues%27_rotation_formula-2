#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/Rodrigues%27_rotation_formula
#c# 2021-09-29 NOT ON RC
#p# OK
#n# a little more idiomatic

use strict;
use warnings;
use feature 'say';

use feature <say signatures>;
no warnings 'experimental::signatures';

use Math::Trig;

use constant PI => 2 * atan2(1, 0);
 
sub norm ( $v ) {
    ($v->[0]*$v->[0] + $v->[1]*$v->[1] + $v->[2]*$v->[2]) ** 0.5
}

sub normalize ( $v ) {
    my $length = norm($v);
    [$v->[0]/$length, $v->[1]/$length, $v->[2]/$length]
}

sub dotProduct ( $v1, $v2 ) {
    $v1->[0]*$v2->[0] + $v1->[1]*$v2->[1] + $v1->[2]*$v2->[2]
}

sub crossProduct ( $v1, $v2 ) {
#   [$v1->[1]*$v2->[2] - $v1->[2]*$v2->[1], $v1->[2]*$v2->[0] - $v1->[0]*$v2->[2], $v1->[0]*$v2->[1] - $v1->[1]*$v2->[0]]
    [$$v1[1]*$$v2[2] - $$v1[2]*$$v2[1], $$v1[2]*$$v2[0] - $$v1[0]*$$v2[2], $$v1[0]*$$v2[1] - $$v1[1]*$$v2[0]]
}

sub getAngle ( $v1, $v2 ) {
    acos(dotProduct($v1, $v2) / (norm($v1)*norm($v2)))*180/PI
}

sub matrixMultiply ( $matrix, $v ) {
    [dotProduct($matrix->[0], $v), dotProduct($matrix->[1], $v), dotProduct($matrix->[2], $v)]
}

sub aRotate ( $p, $v, $a ) {
    my $ca = cos $a/180*PI;
    my $sa = sin $a/180*PI;
    my $t = 1 - $ca;
    my($x,$y,$z) = @$v;
    my $r = [
        [$ca + $x*$x*$t, $x*$y*$t - $z*$sa, $x*$z*$t + $y*$sa],
        [$x*$y*$t + $z*$sa, $ca + $y*$y*$t, $y*$z*$t - $x*$sa],
        [$z*$x*$t - $y*$sa, $z*$y*$t + $x*$sa, $ca + $z*$z*$t]
    ];
    matrixMultiply($r, $p)
}
 
my($v1,$v2) = ([5,-6,  4], [8, 5,-30]);
say my $result = join ' ', @{aRotate $v1, normalize(crossProduct $v1, $v2), getAngle $v1, $v2};

my $ref = '2.23222107330823 1.39513817081764 -8.37082902490585';

use Test::More;
is ($result, $ref);
done_testing();
