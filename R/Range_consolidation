#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/Range_consolidation
#t# skiptest
#c# 2018-08-17 <RC
#p# OK

use warnings;
use strict;
use feature 'say';
my $result;
my @res;

use utf8;
binmode STDOUT, ':encoding(utf-8)';

# Union
#sub infix:<∪> (Range $a, Range $b) { Range.new( min($a.min,$b.min), max($a.max,$b.max) ) }
 
# Intersection
#sub infix:<∩> (Range $a, Range $b) { so $a.max >= $b.min }
 
#multi consolidate() { () }
 
#multi consolidate($this is copy, **@those) {
#    gather {
#        for consolidate |@those -> $that {
#            if $this ∩ $that { $this ∪= $that }
#            else             { take $that }
#        }
#        take $this;
#    }
#}
 
for my $intervals (
    [[1.1, 2.2],],
    [[6.1, 7.2], [7.2, 8.3]],
    [[4, 3], [2, 1]],
    [[4, 3], [2, 1], [-1, -2], [3.9, 10]],
    [[1, 3], [-6, -1], [-4, -5], [8, 2], [-6, -6]]) {
        my @temp;
        push @temp, '[' . join(', ', @$_) for @$intervals;
        push @res, sprintf "%46s => %s", '[' . join('], ', @temp) . ']', 'xxx';
        #@res[*-1] ~= (reverse consolidate |@intervals».sort.sort({ [.[0], .[1]] }).map: { Range.new(.[0], .[1]) }).gist
}

say for @res; exit;

my $ref = <<'END';
                                 [[1.1, 2.2],] => (1.1..2.2)
                      [[6.1, 7.2], [7.2, 8.3]] => (6.1..8.3)
                              [[4, 3], [2, 1]] => (1..2 3..4)
         [[4, 3], [2, 1], [-1, -2], [3.9, 10]] => (-2..-1 1..2 3..10)
[[1, 3], [-6, -1], [-4, -5], [8, 2], [-6, -6]] => (-6..-1 1..8)
END
