#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/Random_number_generator_(device)
#c# 2018-08-19 <RC
#p# OK
#n# simple-minded testing, 1st test might fail once a year (or not)

use feature 'say';

# Typically one would use a module as they will work on UNIX, Win32, and other O/S's. 
# Crypt::Random::Seed, for instance, will use Win32 sources, EGD/PRNGD, /dev/u?random, 
# or if none of those exist for some reason, a userspace entropy method.

use Crypt::Random::Seed;
my $source = Crypt::Random::Seed->new( NonBlocking => 1 ); # Allow non-blocking sources like /dev/urandom
print "$_ " for $source->random_values(10);                # A method returning an array of 32-bit values
say '';

# or (similar but many more dependencies):
#use Crypt::Random::Source qw/get_weak/;    # Alternately get_strong
#print unpack('L*',get_weak(4)), "\n" for 1..10;

# Or we can read values from /dev/urandom ourselves:
sub read_random {
        my $device = '/dev/urandom';
        open my $in, "<:raw", $device   # :raw because it's not unicode string
                or die "Can't open $device: $!";
 
        sysread $in, my $rand, 4 * shift;
        unpack('L*', $rand);
}
 
my($max,$eps) = (1e7, .001);
my($lastA,$lastB,$A,$B,$c_mid);
$A = substr read_random(1), -1, 1;
do { $B = substr read_random(1), -1, 1 } until $A ne $B;

for my $rn (read_random($max)) {
    $c_mid++ if 4294967295/2 < $rn;
    $lastA++ if $A eq substr $rn, -1, 1;
    $lastB++ if $B eq substr $rn, -1, 1;
}

say '';
say abs($c_mid/($max/2)) . ' half/half';
say "$A:$lastA vs $B:$lastB final digits";

use Test::More;
ok 1-abs($c_mid/($max/2)) < $eps;
ok 1-abs($lastA/($lastB)) < 10*$eps;
done_testing();
