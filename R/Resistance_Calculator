#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/Resistance_Calculator
#c# 2019-03-30 >RC
#p# OK

use strict;
use warnings;
use feature 'say';
my @res;

#-------------------
#package Resistor;
#has Str        $.symbol;
#has Numeric  ( $.voltage, $.resistance );
#has Resistor ( $.a, $.b );

package Resistor;

sub new {
    my ($class, $args) = @_;
    my $self = {
        symbol     => $args->{symbol},
        voltage    => $args->{voltage},
        resistance => $args->{resistance},
        a          => $args->{a},
        b          => $args->{b},
    };
    return bless $self, $class;
}

#-------------------
#sub res ( ) {
#    given $!symbol {
#        when '+' { return $!a.res + $!b.res }
#        when '*' { return 1 / (1 / $!a.res  +  1 / $!b.res) }
#        default  { return $!resistance }
#    }
#}

sub res {
    my $self = shift;
    if    ($self->{symbol} eq '+') { return res($self->{a}) + res($self->{b}) }
    elsif ($self->{symbol} eq '*') { return 1 / (1/res($self->{a}) + 1/res($self->{b})) }
    else  { return $self->{resistance} }
}

#-------------------
#sub set_voltage ( Numeric $voltage ) {
#    given $!symbol {
#        when '+' {
#            my $ra = $!a.res;
#            my $rb = $!b.res;
#            $!a.set_voltage( $ra / ($ra+$rb) * $voltage );
#            $!b.set_voltage( $rb / ($ra+$rb) * $voltage );
#        }
#        when '*' {
#            $!a.set_voltage( $voltage );
#            $!b.set_voltage( $voltage );
#        }
#    }
#    $!voltage = $voltage;
#}

sub set_voltage {
    my($self,$voltage) = @_;
    if ($self->{symbol} eq '+') { 
        my $ra = res($self->{a});
        my $rb = res($self->{b});
        set_voltage($self->{a}, $ra / ($ra+$rb) * $voltage );
        set_voltage($self->{b}, $rb / ($ra+$rb) * $voltage );
    } elsif ($self->{symbol} eq '*') { 
        set_voltage($self->{a}, $voltage );
        set_voltage($self->{b}, $voltage );
    }
    $self->{voltage} = $voltage;
}

#-------------------
#sub current ( ) { return $.voltage / self.res     }
#sub effect  ( ) { return $.voltage * self.current }

sub current { my $self = shift; return $self->{voltage} / res($self)     }
sub effect  { my $self = shift; return $self->{voltage} * current($self) }

#-------------------
#sub report ( Int $level = 1 ) {
#    my $pad = '| ' x $level;
#    my $f = ( self.res, $!voltage, self.current, self.effect ).fmt('%8.3f');
#    @res.push: "$f $pad$!symbol";
#    $!a.report( $level+1 ) if $!a;
#    $!b.report( $level+1 ) if $!b;
#}

sub report {
    my $self  = shift;
    my $level = shift || 1;
    my $pad = ('| ') x $level;
    my $fmt = '%9.3f' x 4;
    my $f = sprintf "$fmt", res($self), $self->{voltage}, current($self), effect($self);
    push @res, "$f $pad" . $self->{symbol};
    report($self->{a}, $level+1 ) if defined $self->{a};
    report($self->{b}, $level+1 ) if defined $self->{b};
}

#package main;

#-------------------
#multi sub infix:<+> (Resistor $a, Resistor $b) { $a.new( symbol => '+', :$a, :$b ) }
#multi sub infix:<*> (Resistor $a, Resistor $b) { $a.new( symbol => '*', :$a, :$b ) }

sub js { my($a,$b) = @_; Resistor->new( {symbol => '+', a => $a, b => $b} ) }
sub jp { my($a,$b) = @_; Resistor->new( {symbol => '*', a => $a, b => $b} ) }

#-------------------
#my Resistor ($R1, $R2, $R3, $R4, $R5, $R6, $R7, $R8, $R9, $R10) =
#    map { Resistor.new: symbol => 'r', resistance => $_ },
#    6, 8, 4, 8, 4, 6, 8, 10, 6, 2;

my ($R1, $R2, $R3, $R4, $R5, $R6, $R7, $R8, $R9, $R10) =
    map { Resistor->new( {symbol => 'r', resistance => $_} ) } <6 8 4 8 4 6 8 10 6 2>;

#-------------------
#my $node = (((($R8 + $R10) * $R9 + $R7) * $R6 + $R5)
#                           * $R4 + $R3) * $R2 + $R1;
#$node.set_voltage(18);

##my $nodex = js(jp((
#            js(jp((
#             js(jp(( 
#              js(jp(js($R8,$R10),$R9),$R7)
#             ),
#                $R6),$R5)
#            ) , $R4),$R3)
#           ), $R2) , $R1);

my $node = js(jp((js(jp((js(jp((js(jp(js($R8,$R10),$R9),$R7)),$R6),$R5)),$R4),$R3)),$R2),$R1); 
set_voltage($node,18);

@res = '      Ohm     Volt   Ampere     Watt   Network tree';
report($node);

say my $result = join "\n", @res;

my $ref = <<'EOD';
      Ohm     Volt   Ampere     Watt   Network tree
   10.000   18.000    1.800   32.400 | +
    4.000    7.200    1.800   12.960 | | *
    8.000    7.200    0.900    6.480 | | | +
    4.000    3.600    0.900    3.240 | | | | *
    8.000    3.600    0.450    1.620 | | | | | +
    4.000    1.800    0.450    0.810 | | | | | | *
   12.000    1.800    0.150    0.270 | | | | | | | +
    4.000    0.600    0.150    0.090 | | | | | | | | *
   12.000    0.600    0.050    0.030 | | | | | | | | | +
   10.000    0.500    0.050    0.025 | | | | | | | | | | r
    2.000    0.100    0.050    0.005 | | | | | | | | | | r
    6.000    0.600    0.100    0.060 | | | | | | | | | r
    8.000    1.200    0.150    0.180 | | | | | | | | r
    6.000    1.800    0.300    0.540 | | | | | | | r
    4.000    1.800    0.450    0.810 | | | | | | r
    8.000    3.600    0.450    1.620 | | | | | r
    4.000    3.600    0.900    3.240 | | | | r
    8.000    7.200    0.900    6.480 | | | r
    6.000   10.800    1.800   19.440 | | r
EOD

use Test::More;
chomp $ref;
is($result, $ref);
done_testing();
