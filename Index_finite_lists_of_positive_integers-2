#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/Index_finite_lists_of_positive_integers
#c# 2018-09-07 >RC
#p# BROKEN

use feature 'say';

#use bigint;
#use ntheory qw(todigits fromdigits todigitstring);

srand 123456;

# Here is a bijective solution that does not use string operations.

multi infix:<rad> ()       { 0 }
multi infix:<rad> ($a)     { $a }
multi infix:<rad> ($a, $b) { $a * $*RADIX + $b }

multi expand(Int $n is copy, 1) { $n }
multi expand(Int $n is copy, Int $*RADIX) {
    my \RAD = $*RADIX;

    my @reversed-digits = gather while $n > 0 {
        take $n % RAD;
        $n div= RAD;
    }

    eager for ^RAD {
        [rad] reverse @reversed-digits[$_, * + RAD ... *]
    }
}

multi compress(@n where @n == 1) { @n[0] }
multi compress(@n is copy) {
    my \RAD = my $*RADIX = @n.elems;

    [rad] reverse gather while @n.any > 0 {
            (state $i = 0) %= RAD;
            take @n[$i] % RAD;
            @n[$i] div= RAD;
            $i++;
        }
}

sub rank{ my(@n) = @_;   compress (compress(@n), @n - 1)}
sub unrank{ my($n) = @_; my ($a, $b) = expand $n, 2; expand $a, $b + 1 }

# [1 0 7 9 5 5 5 7 3 5 5 3] -> 4916298568465569231750539
#my @list = (^10).roll((2..20).pick);
my @list = qw<1 0 7 9 5 5 5 7 3 5 5 3>;

my $rank = rank @list;

#say my $result = "[$@list] -> $rank -> [{unrank $rank}]";

#for ^10 {
#    my @unrank = unrank $_;
#    say "$_ -> [$@unrank] -> {rank @unrank}";
#}

say $result = join "\n", @res;

my $ref = <<'EOD';
EOD

use Test::More;
@n = sort { -1 + 2*int(rand 2) } 1..1000;
is (@n, unrank(rank(@n)));
chop $ref;
is ($result, $ref);
done_testing();

__END__

=={{header|Perl}}==
{{trans|Perl 6}}
<lang perl></lang>
{{out}}
<pre>
</pre>
