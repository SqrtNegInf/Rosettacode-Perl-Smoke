#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/Fortunate_numbers
#c# 2021-08-02 >RC
#p# OK
#n# a little more efficient

use strict;
use warnings;
use feature 'say';

use List::Util <first uniq max>;
use ntheory <pn_primorial is_prime>;

my $upto = 50;
my @candidates;

sub table { my $t = 10 * (my $c = 1 + length max @_); ( sprintf( ('%'.$c.'d')x@_, @_) ) =~ s/.{1,$t}\K/\n/gr }

#for my $n ( 1..2*$upto ) {
#    push @candidates, first { is_prime($_ + pn_primorial($n)) } 2..100*$upto;
#}

for my $p ( map { pn_primorial($_) } 1..2*$upto ) {
    push @candidates, first { is_prime($_ + $p) } 2..100*$upto;
}

my @fortunate = sort { $a <=> $b } uniq grep { is_prime $_ } @candidates;

say my $result = "First $upto distinct fortunate numbers:\n" . table @fortunate[0..49];

my $ref = <<'END';
First 50 distinct fortunate numbers:
   3   5   7  13  17  19  23  37  47  59
  61  67  71  79  89 101 103 107 109 127
 151 157 163 167 191 197 199 223 229 233
 239 271 277 283 293 307 311 313 331 353
 373 379 383 397 401 409 419 421 439 443
END

use Test::More;
is($result, $ref);
done_testing;
