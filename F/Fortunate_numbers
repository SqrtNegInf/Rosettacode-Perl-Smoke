#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/Fortunate_numbers
#c# 2021-08-02 >RC
#p# OK
#n# a little more efficient

use strict;
no warnings;
use feature 'say';

use List::Util <first uniq>;
use ntheory <pn_primorial is_prime>;

my $upto = 50;
my @candidates;

#for my $n ( 1..2*$upto ) {
#    push @candidates, first { is_prime($_ + pn_primorial($n)) } 2..100*$upto;
#}

for my $p ( map { pn_primorial($_) } 1..2*$upto ) {
    push @candidates, first { is_prime($_ + $p) } 2..100*$upto;
}

my @fortunate = sort { $a <=> $b } uniq grep { is_prime $_ } @candidates;

say my $result = "First $upto distinct fortunate numbers:\n" .
    (sprintf "@{['%6d' x $upto]}", @fortunate) =~ s/(.{60})/$1\n/gr;

my $ref = <<'END';
First 50 distinct fortunate numbers:
     3     5     7    13    17    19    23    37    47    59
    61    67    71    79    89   101   103   107   109   127
   151   157   163   167   191   197   199   223   229   233
   239   271   277   283   293   307   311   313   331   353
   373   379   383   397   401   409   419   421   439   443
END

use Test::More;
is($result, $ref);
done_testing;
