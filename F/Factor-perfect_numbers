#!/usr/local/bin/perl
#u# https://rosettacode.org/wiki/Factor-perfect_numbers
#t# inprogress
#c# 2023-02-26 >RC
#p# OK

my @res;

use v5.36;

use ntheory 'divisors';
use enum qw(False True);
#use List::AllUtils <firstidx sum>;

sub table (@V) { my $t = 3 * (my $w = 2 + 20); ( sprintf( ('%-'.$w.'s')x@V, @V) ) =~ s/.{1,$t}\K/\n/gr }

my $n = 4;
my @fpns = (0, 1);
my %cache;

sub proper_divisors ($x) {
   my @l;
   @l = 1 if $x > 1;
   for my $d (2 .. int sqrt $x) {
      if (0 == $x % $d) { push @l, $d; my $y = int($x/$d); push @l, $y if $y != $d }
   }
   @l
}

sub erdosFactorCount ($n) {
   my @foo = proper_divisors($n); shift @foo;
   my ($sum,@divs) = (0, @foo); #(proper_divisors $n)[1..*]);
   for my $d (@divs) {
      my $t = int($n/$d);
      unless (exists $cache{$t}) { $cache{$t} = erdosFactorCount($t) }
      $sum += $cache{$t}
   }
   return $sum + 1
}

sub moreMultiples ($to, $from) {
   my @oneMores;
   for my $j (@$from) {
      push @oneMores, [@$to, $j] if $j > $$to[-1] && 0 == $j % $$to[-1]
   }
   return unless @oneMores;
   for (0 .. $#oneMores) {
      push @oneMores, moreMultiples($oneMores[$_], $from);
   }
   return @oneMores
}

my @listing = [1];
push @listing, moreMultiples [1], [proper_divisors(48)];
map { push @$_, 48 } @listing;

my $result = @listing . " sequences using first definition:\n";
my @lists; map { push @lists, join ' ', @$_ } @listing;
$result .= table(@lists);

say $result; # = join "\n", @res;

my $ref = <<'END';
48 sequences using first definition:
1 48                  1 2 48                1 24 48               
1 3 48                1 16 48               1 4 48                
1 12 48               1 6 48                1 8 48                
1 2 24 48             1 2 16 48             1 2 4 48              
1 2 12 48             1 2 6 48              1 2 8 48              
1 2 4 24 48           1 2 4 16 48           1 2 4 12 48           
1 2 4 8 48            1 2 4 12 24 48        1 2 4 8 24 48         
1 2 4 8 16 48         1 2 12 24 48          1 2 6 24 48           
1 2 6 12 48           1 2 6 12 24 48        1 2 8 24 48           
1 2 8 16 48           1 3 24 48             1 3 12 48             
1 3 6 48              1 3 12 24 48          1 3 6 24 48           
1 3 6 12 48           1 3 6 12 24 48        1 4 24 48             
1 4 16 48             1 4 12 48             1 4 8 48              
1 4 12 24 48          1 4 8 24 48           1 4 8 16 48           
1 12 24 48            1 6 24 48             1 6 12 48             
1 6 12 24 48          1 8 24 48             1 8 16 48             

END

__END__

my @listing2 = gather for (0..^+@listing) -> \j {
   my @seq = |@listing[j];
   @seq.append: 48 if @seq[*-1] != 48;
   take (1..^+@seq).map: { @seq[$_] div @seq[$_-1] }
}
@res.push: "\n{@listing2.elems} sequences using second definition:";
$out = '';
for @listing2.rotor(4) -> \line { line.map: { $out  ~= sprintf "%-20s", $_ } ; $out ~= "\n" }
@res.push: $out;

use Test::More;
chomp $ref;
is($result, $ref);
#is(($result =~ s/\s//gr), ($ref =~ s/\s//gr));
done_testing();

__END__

=={{header|Perl}}==
{{trans|Raku}}
{{libheader|ntheory}}
<syntaxhighlight lang="perl" line>
</syntaxhighlight>
{{out}}
<pre>
</pre>
