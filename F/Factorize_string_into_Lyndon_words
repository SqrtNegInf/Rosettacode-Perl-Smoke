#!/usr/local/bin/perl
#u# https://www.rosettacode.org/wiki/Factorize_string_into_Lyndon_words
#c# 2024-09-08 <RC
#p# OK

my @res;

use strict;
use warnings;
use feature 'say';

sub chenfoxlyndonfactorization {
   my ($s) = @_;
   my ($n, $i, @factorization) = (length($s), 0);
   while ($i < $n) {
      my ($j, $k) = ($i+1, $i);
      while ($j < $n && substr($s, $k, 1) le substr($s, $j, 1)) {
         (substr($s, $k, 1) lt substr($s, $j, 1)) ?  $k = $i : $k++;
         $j++
      }
      while ($i <= $k) {
         my $substring = substr($s, $i, $j - $k);
         push @factorization, $substring;
         $i += $j - $k
      }
   }
   return \@factorization;
}

my $m = "0";
for my $i (1..7) { $m .= ($m =~ tr/01/10/r) }
my $factors = chenfoxlyndonfactorization($m);
push @res, "[" . join(" ", @$factors) . "]";

say my $result = join "\n", @res;

my $ref = <<'EOD';
[011 01 0011 00101101 0010110011010011 00101100110100101101001100101101 001011001101001011010011001011001101001100101101 001011001101 001]
EOD

use Test::More;
chomp $ref;
is ($result, $ref);
done_testing();
