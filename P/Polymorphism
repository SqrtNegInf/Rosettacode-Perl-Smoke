#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/Polymorphism
#c# 2018-08-20 <RC
#p# OK

use strict;
use warnings;
use feature 'say';
my $result;

# What polymorphic function means in the context of Perl is as clear as mud. subs already can take anything as parameter by default. Destructors are automatic, so I dropped them.

{
     package Point;
     use Class::Spiffy -base;
     use Clone qw(clone);

     sub _print {
          my %self = %{shift()};
          $result .= 'x: ' . $self{'x'} . ' ';
          $result .= 'y: ' . $self{'y'} . ' ';
     }

     sub members {
         no strict;
         grep {
             1 == length and defined *$_{CODE}
         } keys %{*{__PACKAGE__."\::"}};
     }

     sub new {
         my $class = shift;
         my %param = @_;
         $param{$_} = 0 for grep {!defined $param{$_}} members;
         bless \%param, $class;
     }

     sub copy_constructor {
         clone shift;
     }

     sub copy_assignment {
         my $self = shift;
         my $from = shift;
         $self->$_($from->$_) for $from->members;
     }

     field 'x';
     field 'y';
}

{
     package Circle;
     use base qw(Point);
     field 'r';
}

{
     package main;
     $_->_print for (
        Point->new,
        Point->new(x => 2),
        Point->new(y => 3),
        Point->new(x => 8, y => -5),
     );
     my $p1 = Point->new(x => 8, y => -5);

     my $p2 = $p1->copy_constructor;
     $result .= "\nwe are really different objects, not just references ".
           "to the same instance\n" unless \$p1 eq \$p2;

     # accessors autogenerated
     $p1->x(1);
     $p1->y(2);
     $result .= $p1->x. "\n";
     $result .= $p1->y. "\n";

     $p2->copy_assignment($p1);
     $result .= $p2->x. "\n";
     $result .= $p2->y. "\n";
     $result .= "\nwe now have the same values, but we are still ".
           "different objects\n" unless \$p1 eq \$p2;

      $_->_print, $result .= "\n" for (
         Circle->new,
         Circle->new(x => 1),
         Circle->new(y => 2),
         Circle->new(r => 3),
         Circle->new(x => 4, y => 5),
         Circle->new(x => 6, r => 7),
         Circle->new(y => 8, r => 9),
         Circle->new(x => 1, y => 2, r => 3),
      );

     my $c = Circle->new(r => 4);
     $result .= $c->r . "\n"; # accessor autogenerated
}


say $result;
my $ref = <<'EOD';
x: 0 y: 0 x: 2 y: 0 x: 0 y: 3 x: 8 y: -5 
we are really different objects, not just references to the same instance
1
2
1
2

we now have the same values, but we are still different objects
x: 0 y: 0 
x: 1 y: 0 
x: 0 y: 2 
x: 0 y: 0 
x: 4 y: 5 
x: 6 y: 0 
x: 0 y: 8 
x: 1 y: 2 
4
EOD
use Test::More;
is ($result, $ref);
done_testing;
