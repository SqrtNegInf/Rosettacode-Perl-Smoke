#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/Problem_of_Apollonius
#c# 2018-09-20 >RC
#p# OK

use strict;
use warnings;
use feature 'say';
my $result;

use utf8;
use Math::Cartesian::Product;

package Circle;

sub new {
    my ($class, $args) = @_;
    my $self = {
        x => $args->{x},
        y => $args->{y},
        r => $args->{r},
    };
    #bless $self, $class;
}

sub show {
    my ($self, $args) = @_;
    sprintf "x =%7.3f  y =%7.3f  r =%7.3f\n", $args->{x}, $args->{y}, $args->{r}; 
}

package main;

sub circle {
    my($x,$y,$r) = @_; 
    Circle->new({ x => $x, y=> $y, r => $r });
}

sub solve_Apollonius {
    my($c1, $c2, $c3, $s1, $s2, $s3) = @_;

    my $ð‘£11 = 2 * $c2->{x} - 2 * $c1->{x};
    my $ð‘£12 = 2 * $c2->{y} - 2 * $c1->{y};
    my $ð‘£13 = $c1->{x}**2 - $c2->{x}**2 + $c1->{y}**2 - $c2->{y}**2 - $c1->{r}**2 + $c2->{r}**2;
    my $ð‘£14 = 2 * $s2 * $c2->{r} - 2 * $s1 * $c1->{r};

    my $ð‘£21 = 2 * $c3->{x} - 2 * $c2->{x};
    my $ð‘£22 = 2 * $c3->{y} - 2 * $c2->{y};
    my $ð‘£23 = $c2->{x}**2 - $c3->{x}**2 + $c2->{y}**2 - $c3->{y}**2 - $c2->{r}**2 + $c3->{r}**2;
    my $ð‘£24 = 2 * $s3 * $c3->{r} - 2 * $s2 * $c2->{r};

    my $ð‘¤12 = $ð‘£12 / $ð‘£11;
    my $ð‘¤13 = $ð‘£13 / $ð‘£11;
    my $ð‘¤14 = $ð‘£14 / $ð‘£11;

    my $ð‘¤22 = $ð‘£22 / $ð‘£21 - $ð‘¤12;
    my $ð‘¤23 = $ð‘£23 / $ð‘£21 - $ð‘¤13;
    my $ð‘¤24 = $ð‘£24 / $ð‘£21 - $ð‘¤14;

    my $ð‘ƒ = -$ð‘¤23 / $ð‘¤22;
    my $ð‘„ = $ð‘¤24 / $ð‘¤22;
    my $ð‘€ = -$ð‘¤12 * $ð‘ƒ - $ð‘¤13;
    my $ð‘ = $ð‘¤14 - $ð‘¤12 * $ð‘„;

    my $ð‘Ž = $ð‘**2 + $ð‘„**2 - 1;
    my $ð‘ = 2 * $ð‘€ * $ð‘ - 2 * $ð‘ * $c1->{x} + 2 * $ð‘ƒ * $ð‘„ - 2 * $ð‘„ * $c1->{y} + 2 * $s1 * $c1->{r};
    my $ð‘ = $c1->{x}**2 + $ð‘€**2 - 2 * $ð‘€ * $c1->{x} + $ð‘ƒ**2 + $c1->{y}**2 - 2 * $ð‘ƒ * $c1->{y} - $c1->{r}**2;

    my $ð· = $ð‘**2 - 4 * $ð‘Ž * $ð‘;
    my $rs = (-$ð‘ - sqrt $ð·) / (2 * $ð‘Ž);

    my $xs = $ð‘€ + $ð‘ * $rs;
    my $ys = $ð‘ƒ + $ð‘„ * $rs;

    circle($xs, $ys, $rs);
}

my $c1 = circle(0, 0, 1);
my $c2 = circle(4, 0, 1);
my $c3 = circle(2, 4, 2);

# another way of looking at cross-product
# use Algorithm::Combinatorics qw/tuples_with_repetition/;
# for (tuples_with_repetition([qw/-1 1/],3)) {

for (cartesian {@_} ([-1,1])x3) {
    $result .= Circle->show( solve_Apollonius $c1, $c2, $c3, @$_);
}

print $result;

my $ref = <<'EOD';
x =  2.000  y =  0.833  r =  1.167
x =  2.000  y =  3.214  r =  2.786
x =  3.002  y =  0.123  r =  2.005
x =  4.127  y =  3.252  r =  4.255
x =  0.998  y =  0.123  r =  2.005
x = -0.127  y =  3.252  r =  4.255
x =  2.000  y = -1.500  r =  3.500
x =  2.000  y =  2.100  r =  3.900
EOD

use Test::More;
is($result,$ref);
done_testing;
