#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/Generate_random_chess_position
#c# 2019-02-05 >RC
#p# BROKEN

use feature 'say';
use warnings;
use Data::Printer;
#use strict 'vars';

srand 12345;

sub pick_FEN {
    # First we chose how many pieces to place
    my $n = 1 + int rand 31;

    # Then we pick $n squares
    my @n = (shuffle(0..63))[1..$n];

say "n: $n :: ", join ' ', @n; #exit;

    KINGS: {
    for my $a (@n) {
        for my $b (@n) {
            next unless $a != $b && abs(int($a/8) - int($b/8)) > 1 || abs($a%8 - $b%8) > 1;
            @kings = ($a, $b);  
            last KINGS;
        }
        die 'No good place for kings!';
    }
    }
    say join ', ', @kings;
$DB::single = 1;

    # We make a list of pieces we can pick (apart from the kings)
    my @pieces = qw<p P n N b B r R q Q>;

    # We make a list of two king symbols to pick randomly a black or white king
    my @k = pick1(qw(K k));

p @k ; exit;

    #return (gather for ^64 -> $sq 
    for my $sq (0..63) {
        #if ( $sq == @kings.any ) { push @pp, shift @k }
        #elsif ( $sq == @n.any ) {
            $row = 7 - int $sq / 8;
            push @pp,  
            $row == 0 ? pick1(grep { $_ ne 'P' } @pieces ) :
            $row == 7 ? pick1(grep { $_ ne 'P' } @pieces ) :
            pick1(@pieces);
        #}
        #else { push @pp, 'ø' }
    }
    #$DB::single = 1;
    say join ' ', @pp;
    # manip @pp
    #.rotor(8)».join».subst(/ø+/,{ .chars }, :g).join('/') ~ ' w - - 0 1';
}

say my $result = pick_FEN();

sub pick1 { return @_[ rand @_ ] } 

# http://en.wikipedia.org/wiki/Fisher-Yates_shuffle#The_modern_algorithm
sub shuffle {
    my(@list) = @_;
    for (my $n = $#list ; $n ; --$n) {
        my $k = int rand($n + 1);
        @list[$k, $n] = @list[$n, $k] if $k != $n;
    }
    return @list;
}

#is $result, '1r6/8/7r/8/1B2k3/4PR1K/1r6/3P1R2 w - - 0 1'

use Test::More;
#is($result, $ref);
#done_testing();

__END__

=={{header|Perl}}==
{{trans|Perl 6}}
<lang perl></lang>
{{out}}
<pre style="height:35ex"></pre>
