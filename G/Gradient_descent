#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/Gradient_descent
#t# inprogress
#c# 2019-11-xx >RC
#p# OK

use Data::Printer;
use Time::HiRes qw(sleep);

use strict;
use warnings;
use feature 'say';

my @res;

__END__

sub steepestDescent(@x, $alpha is copy, $tolerance) {
    my \N = +@x; my $h = $tolerance ;
    my $g0 = g(@x) ;    # Initial estimate of result.

    my @fi = gradG(@x, $h) ;    #  Calculate initial gradient

    # Calculate initial norm.
    my $delG = 0;
    for ^N { $delG += @fi[$_]² }
    my $b = $alpha / $delG.sqrt;

    while ( $delG > $tolerance ) {   # Iterate until value is <= tolerance.
       #  Calculate next value.
       for ^N { @x[$_] -= $b * @fi[$_] }
       $h /= 2;

       @fi = gradG(@x, $h);    # Calculate next gradient.

       # Calculate next norm.
       $delG = 0;
       for ^N { $delG += @fi[$_]² }
       $b = $alpha / $delG.sqrt;

       my $g1 = g(@x);   # Calculate next value.

       $g1 > $g0 ?? ( $alpha /= 2 ) !! ( $g0 = $g1 )   # Adjust parameter.
    }
}

sub gradG(@x, $h) {   # Provides a rough calculation of gradient g(x).
    my \N = +@x ; my ( @y , @z );
    @y = @x;
    my $g0 = g(@x);
    for ^N { @y[$_] += $h ; @z[$_] = (g(@y) - $g0) / $h }
    return @z
}

# Function for which minimum is to be found.
# exp = 2.718281828459045
sub g(\x) { (x[0]-1)**2 * (-x[1]**2).exp + x[1]*(x[1]+2) * (-2*x[0]**2).exp }

my $tolerance = 0.0000006 ; my $alpha = 0.1;

my @x = 0.1, -1; # Initial guess of location of minimum.

steepestDescent(@x, $alpha, $tolerance);

say "Testing steepest descent method:";
say my $result = 'The minimum is at x[0] = ' ~ @x[0] ~ ', x[1] = ' ~ @x[1];

use Test::More;
chomp $ref;
is($result, 'The minimum is at x[0] = 0.10765273561778406, x[1] = -1.223326198625842';
done_testing();

__END__

=={{header|Perl}}==
{{trans|Perl 6}}
<lang perl></lang>
{{out}}
<pre style="height:20ex"></pre>
[https://github.com/SqrtNegInf/Rosettacode-Perl5-Smoke/blob/master/ref/XXX XXX]
