#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/Totient_function
#c# 2018-12-06 >RC
#p# OK
#n# but see -2 variant for ntheory/speed

use feature 'say';
use warnings;

use utf8;
binmode STDOUT, ":utf8";

my @res;

sub gcd {
  my ($u, $v) = @_;
  while ($v) {
    ($u, $v) = ($v, $u % $v);
  }
  return abs($u);
}

# Sidef
#for $t (1..10000) {
#    push @洧램, ?? #($洧램[0]-1) * p[0]**(p[1]-1)
#}

sub totient {
    my($n) = @_;
    $tot = $n;
    for ($i= 2; $i*$i <= $n; $i += 2) {
        if ($n%$i == 0) {
            for ($n%$i == 0) {
                $n /= $i;
            }
            $tot -= $tot / $i;
        }
        $i = 1 if $i == 2;
    }
    $tot -= $tot / $n if $n > 1;
    $tot
} 

push @洧램, 0;
for $t (1..100) {
    push @x, totient($t);
    push @洧램, scalar grep { 1 == gcd($_,$t) } 1..$t;
}

say join ' ', @洧램[0..20];
say join ' ', @x[0..20];
exit;

push @res, sprintf "洧램(%2d) = %3d%s", $_, $洧램[$_], $_ - $洧램[$_] - 1 ? '' : ' Prime' for 1 .. 25;
 
for $limit (100, 1000, 10000) {
    push @res, "\nCount of primes <= $limit: " . grep {$_ == $洧램[$_] + 1} 0..$limit;
}

say $result = join "\n", @res;
exit;

my $ref = <<'EOD';
洧램( 1) =   1
洧램( 2) =   1 Prime
洧램( 3) =   2 Prime
洧램( 4) =   2
洧램( 5) =   4 Prime
洧램( 6) =   2
洧램( 7) =   6 Prime
洧램( 8) =   4
洧램( 9) =   6
洧램(10) =   4
洧램(11) =  10 Prime
洧램(12) =   4
洧램(13) =  12 Prime
洧램(14) =   6
洧램(15) =   8
洧램(16) =   8
洧램(17) =  16 Prime
洧램(18) =   6
洧램(19) =  18 Prime
洧램(20) =   8
洧램(21) =  12
洧램(22) =  10
洧램(23) =  22 Prime
洧램(24) =   8
洧램(25) =  20

Count of primes <= 100: 25

Count of primes <= 1000: 168

Count of primes <= 10000: 1229
EOD

use Test::More;
chop $ref;
is($result, $ref);
done_testing();

__END__

=={{header|Perl}}==
{{trans|Perl 6}}
<lang perl></lang>
{{out}}
<pre style="height:35ex"></pre>
