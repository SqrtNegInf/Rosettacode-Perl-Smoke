#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/Tree_datastructures
#t# inprogress
#c# 2019-11-07 >RC
#p# OK

use Data::Printer;
use Time::HiRes qw(sleep);

use strict;
use warnings;
use feature 'say';

my @res;

my $trees = <<~END;
    RosettaCode
      encourages
        code
          diversity
          comparison
      discourages
        golfing
        trolling
        emphasising execution speed
    code-golf.io
      encourages
        golfing
      discourages
        comparison
    END

# sub nested-to-indent { $^str.subst: / ^^ ($($level))* /, -> $/ { "{+$0} " }, :g }
# sub indent-to-nested { $^str.subst: / ^^ (\d+) \s* /, -> $/ { "{$level x +$0}" }, :g }

my $level = '  ';
sub nested_to_indent { my($str) = @_; $str =~ s#^($level)*#(length($1)/2 || 0) . ' '#egmr }
#sub indent_to_nested { my($str) = @_; $str =~ s/^ (\d+) \s* /, -> $/ { "{$level x +$1}" }/gx  }

say my $indent = nested_to_indent $trees; exit;
#say my $nest   = indent_to_nested $indent;

__END__
use Test::More;
is($trees, $nest);
done_testing();

__END__

#`(
If, on the other hand, we want perform more complex transformations; better to
load it into a native data structure which will then allow us to manipulate it
however we like.
)

# Import outline paragraph into native data structure
sub import (Str $trees, $level = '  ') {
    my $forest;
    my $last = -Inf;

    for $trees.lines -> $branch {
        $branch ~~ / ($($level))* /;
        my $this = +$0;
        $forest ~= do {
            given $this cmp $last {
                when More { "\['{esc $branch.trim}', " }
                when Same { "'{esc $branch.trim}', " }
                when Less { "{']' x $last - $this}, '{esc $branch.trim}', " }
            }
        }
        $last = $this;
    }

    sub esc { $^s.subst( /(<['\\]>)/, -> $/ { "\\$0" }, :g) }

    $forest ~= ']' x 1 + $last;
    use MONKEY-SEE-NO-EVAL;
    $forest.EVAL;
}

my $forest = import $trees;

push @res, "\nNative data structure:\n" . $forest;

{
    use JSON;
    push @res, "\nJSON:\n" . encode_json $forest;
}

{
    use YAML;
    push @res, "\nYAML:\n"~ $forest.&dump;
}

my $ref = q:to/END/;

Native data structure:
$["RosettaCode", ["encourages", ["code", ["diversity", "comparison"]], "discourages", ["golfing", "trolling", "emphasising execution speed"]], "code-golf.io", ["encourages", ["golfing"], "discourages", ["comparison"]]]

JSON:
[ "RosettaCode", [ "encourages", [ "code", [ "diversity", "comparison" ] ], "discourages", [ "golfing", "trolling", "emphasising execution speed" ] ], "code-golf.io", [ "encourages", [ "golfing" ], "discourages", [ "comparison" ] ] ]

YAML:
---
- RosettaCode
- - encourages
  - - code
    - - diversity
      - comparison
  - discourages
  - - golfing
    - trolling
    - emphasising execution speed
- code-golf.io
- - encourages
  - - golfing
  - discourages
  - - comparison
...

END

#.say for @res;

use Test;
is($trees, $nest, 'Round-trip equals original');
is @res.join("\n"), chomp $ref;

say my $result = join "\n", @res;
my $ref = <<'END';
END

use Test::More;
chomp $ref;
is($result, $ref);
done_testing();

__END__

=={{header|Perl}}==
{{trans|Perl 6}}
{{libheader|ntheory}}
<lang perl></lang>
{{out}}
<pre style="height:20ex"></pre>
[https://github.com/SqrtNegInf/Rosettacode-Perl5-Smoke/blob/master/ref/XXX XXX]
