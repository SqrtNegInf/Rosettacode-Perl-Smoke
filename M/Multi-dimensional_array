#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/RC_REMOTE
#t# skiptest
#c# 2019-02-RC >RC
#p# OK

# 1. State the number and extent of each index to the array.
# 2. Provide specific, ordered, integer indices for all dimensions of the array together with a new value to update the indexed value.
# 3. Provide specific, ordered, numeric indices for all dimensions of the array to obtain the arrays value at that indexed position.

# The task is to
# A. State if the language supports multi-dimensional arrays in its syntax and usual implementation.
# B. State whether the language uses row-major or column major order for multi-dimensional array storage, or any other relevant kind of storage.
# C. Show how to create a four dimensional array in your language and set, access, set to another value; and access the new value of an integer-indexed item of the array.

# D. The array should allow a range of five, four, three and two (or two three four five if convenient), in each of the indices, in order. (For example, if indexing starts at zero for the first index then a range of 0..4 inclusive would suffice).
# E. State if memory allocation is optimised for the array - especially if contiguous memory is likely to be allocated.
# ? If the language has exceptional native multi-dimensional array support such as optional bounds checking, reshaping, or being able to state both the lower and upper bounds of index ranges, then this is the task to mention them.

use Data::Printer;
use feature 'say';

# Perl arrays are internally always one-dimensional, but multi-dimension arrays are supported via references.  So a two-dimensional array is an arrays-of-arrays, (with 'rows' that are references to arrays), while a three-dimensional array is an array of arrays-of-arrays, and so on. There are no arbitrary limits on the sizes or number of dimensions (i.e. the 'depth' of nesting references).  

# To generate a zero-initialized 2x3x4x5 array
for $i (0..1) {
  for $j (0..2) {
    for $k (0..3) {
    #for $l (0..4) {
        #$a[$i][$j][$k][$l] = "$i,$j,$k,$l"; # each 'cell' contains it's own address
        $a[$i][$j][$k][$l] = [(0)x5];
    #}
    }
  }
}
#p @a; exit;

# There is no requirement that the overall shape of array be regular, or that contents of the array elements
# be of the the same type.
# Arrays can contain 
@b = (
     [1, 2, 4, 8, 16, 32],                                                      # numbers
     [<Mon Tue Wed Thu Fri Sat Sun>],                                           # strings
     [sub{$_[0]+$_[1]}, sub{$_[0]-$_[1]}, sub{$_[0]*$_[1]}, sub{$_[0]/$_[1]}]   # coderefs
);
say $b[0][5];           # prints '32'
say $b[1][2];           # prints 'Wed'
say $b[2][0]->(40,2);   # prints '42', sum of 40 and 2

#say ...;
#exit;

#push @powers, 2**$_ for 1..10;
#say join ', ', @powers[2..4];

#my @a2 = [[1], [2, 3, 4], [5, 6]];
#p @a2;
# [
#  [1],
#  [2, 3, 4],
#  [5, 6],
# ]

# Dimensions do not _need_ to be predeclared or pre-allocated. Perl will auto-vivify the necessary storage slots on first access.
$a3[2][2] = 47;

#    [undef]
#    [undef]
#    [undef, undef, 47]

# Negative indicies to count backwards from the end 

say $a3[-1][-1]; # prints '47'

# But pre-allocation is possible, can result in a more efficient memory layout (in general though Perl allows minimal control over memory)
$#$big = 1_000_000;

__END__

my $result;
# my @res;

#Perl 6 supports multi dimension arrays natively. There are no arbitrary limits on the number of dimensions or maximum indices. Theoretically, you could have an infinite number of dimensions of infinite length, though in practice more than a few dozen dimensions gets unwieldy. An infinite maximum index is a fairly common idiom though. You can assign an infinite lazy list to an array and it will only produce the values when they are accessed.
 
@res.push: @integers[100000]; #100001 (arrays are zero indexed.)
 
# Multi dimension arrays may be predeclared which constrains the indices to the declared size:
 
my @dim5[3,3,3,3,3];
 
#Creates a preallocated 5 dimensional array where each branch has 3 storage slots and constrains the size to the declared size.
#It can then be accessed like so:
 
@dim5[0;1;2;1;0] = 'Perl 6';
 
@res.push: @dim5[0;1;2;1;0]; # Perl 6
 
#@dim5[0;1;2;1;4] = 'error'; # runtime error: Index 4 for dimension 5 out of range (must be 0..2)
 
# Note that the dimensions do not _need_ to be predeclared / allocated. Perl 6 will auto-vivify the necessary storage slots on first access.
 
my @a2;
 
@a2[0;1;2;1;0] = 'Perl 6';
 
@a2[0;1;2;1;4] = 'not an error';
 
# It is easy to access array "slices" in Perl 6.
 
my @b = map { [$_ X~ 1..5] }, <a b c d>;
 
@res.push: $_ for @b;
# [a1 a2 a3 a4 a5]
# [b1 b2 b3 b4 b5]
# [c1 c2 c3 c4 c5]
# [d1 d2 d3 d4 d5]
 
@res.push: @b[*;2]; # Get the all of the values in the third "column"
# (a3 b3 c3 d3)
 
# By default, Perl 6 can store any object in an array, and it is not very compact. You can constrain the type of values that may be stored which can allow the optimizer to store them much more efficiently.
 
my @c = 1 .. 10; # Stores integers, but not very compactly since there are no constraints on what the values _may_ be
 
my uint16 @d = 1 .. 10; # Since there are and only can be unsigned 16 bit integers, the optimizer will use a much more compact memory layout.
 
# Indices must be a positive integer. Negative indices are not permitted, fractional indices will be truncated to an integer.

.say for @res;

my $ref = qq:to/END/;
100001
Perl 6
a1 a2 a3 a4 a5
b1 b2 b3 b4 b5
c1 c2 c3 c4 c5
d1 d2 d3 d4 d5
a3 b3 c3 d3
END

use Test;
is @res.join("\n"), chomp $ref;

say $result; 
#say $result = join "\n", @res;
my $ref = <<'EOD';
EOD

use Test::More;
#is($result, $ref);
#done_testing();

__END__

=={{header|Perl}}==
{{trans|Perl 6}}
<lang perl></lang>
{{out}}
<pre style="height:35ex"></pre>
[https://github.com/SqrtNegInf/Rosettacode-Perl5-Smoke/blob/master/ref/XXX XXX]
