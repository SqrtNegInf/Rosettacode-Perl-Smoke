#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/Minimum_positive_multiple_in_base_10_using_only_0_and_1
#c# 2020-03-03 >RC, 2020-03-04 <RC
#p# OK
#n# from Sidef: no special cases, reasonably speedy (~40% faster than using bigint/ntheory combo here)
#n# range adjustment from ++trizen (no difference in output), but why P: <0..$n-1> vs S: <0..n> ?

use strict;
use warnings;
use feature 'say';

my @res;

use Math::AnyNum qw(:overload powmod);

sub B10 {
    my($n) = @_;
    return 0 unless $n;

    my @P = (-1) x $n;
    for (my $m = 0; $P[0] == -1; ++$m) {
        for my $r (0..$n-1) { # 2020-03-04
            next if $P[$r] == -1 or $P[$r] == $m;
            for ((powmod(10, $m, $n) + $r) % $n) { $P[$_] = $m if $P[$_] == -1 }
        }
        for (powmod(10, $m, $n)) { $P[$_] = $m if $P[$_] == -1 }
    }
 
    my $R = my $r = 0;
    do {
        $R += 10**$P[$r];
        $r  = ($r - powmod(10, $P[$r], $n)) % $n
    } while $r > 0;
    $R
}
 
printf "%5s: %28s  %s\n", 'Number', 'B10', 'Multiplier';
 
for my $n (1..10, 95..105, 297, 576, 594, 891, 909, 999, 1998, 2079, 2251, 2277, 2439, 2997, 4878) {
    my $a = B10($n);
    push @res, sprintf "%6d: %28s  %s", $n, $a, $a/$n;
}

say my $result = join "\n", @res;

my $ref = <<'END';
     1:                            1  1
     2:                           10  5
     3:                          111  37
     4:                          100  25
     5:                           10  2
     6:                         1110  185
     7:                         1001  143
     8:                         1000  125
     9:                    111111111  12345679
    10:                           10  1
    95:                       110010  1158
    96:                     11100000  115625
    97:                     11100001  114433
    98:                     11000010  112245
    99:           111111111111111111  1122334455667789
   100:                          100  1
   101:                          101  1
   102:                      1000110  9805
   103:                     11100001  107767
   104:                      1001000  9625
   105:                       101010  962
   297:          1111011111111111111  3740778151889263
   576:              111111111000000  192901234375
   594:         11110111111111111110  18703890759446315
   891:          1111111111111111011  1247038284075321
   909:          1011111111111111111  1112333455567779
   999:  111111111111111111111111111  111222333444555666777889
  1998: 1111111111111111111111111110  556111667222778333889445
  2079:       1001101101111111111111  481530111164555609
  2251:                 101101101111  44913861
  2277:         11110111111111111011  4879275850290343
  2439:   10000101011110111101111111  4100082415379299344449
  2997: 1111110111111111111111111111  370740777814851888925963
  4878:  100001010111101111011111110  20500412076896496722245
END

use Test::More;
chomp $ref;
is($result, $ref);
done_testing;
