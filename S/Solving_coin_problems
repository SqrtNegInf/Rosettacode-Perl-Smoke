#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/Solving_coin_problems
#c# 2020-01-22 <RC, 2020-01-23 >RC
#p# OK
#f# RC file: solving_coin_problems.dat

my @res;

use strict;
use warnings;
use feature 'say';

use List::Util qw(sum uniq);

my %nums = (
        zero        => 0,   one       => 1,     two      => 2,    three    => 3,
        four        => 4,   five      => 5,     six      => 6,    seven    => 7,
        eight       => 8,   nine      => 9,     ten      => 10,   eleven   => 11,
        twelve      => 12,  thirteen  => 13,    fourteen => 14,   fifteen  => 15,
        sixteen     => 16,  seventeen => 17,    eighteen => 18,   nineteen => 19,
        twenty      => 20,  
);

my(@words,@eqns,@vars,@types);
my $decimal = qr/(?:[1-9][0-9]*\.?[0-9]*)|(?:0?\.[0-9]+)/;

sub add_type {
        my($type,$value) = @_;
        push @vars, "v_$type: $value";
        push @types, $type;
}

open my $results,  '>', 'run/solving_coin_problems.dat' or die;
open my $problems, '<', 'ref/solving_coin_problems.txt' or die;

while (<$problems>) {
    chomp $_;
    my($count,$total) = (0, 0);
    @words = @eqns = @vars = @types = ();

    next if /^\s*$/ or /^\s*#.*$/; # skip blank and comment lines

    s/-/ /g;                       # convert hyphens to spaces
    $_ = lc($_);                   # convert to lower case
    s/\s+/ /g; s/ $//; s/^ //;     # trim whitespace

    # tokenize sentence boundaries, punctuation, symbols
    s/([\.\?\!]) / $1\n/g;
    s/([\.\?\!])$/ $1\n/g;
    s/\$(.)/\$ $1/g;               # prefix
    s/(.)([\;\:\%',¢])/$1 $2/g;    # suffix
    s/\btwice\b/two times/g;

    # fractions
    s/half.dollars?/half_dollar/g;
    s/\b(one )?half\b/0.5/g;

    # remove non-essential words
    s/\b(the|a|to|of|i|is|that|it|on|you|this|for|but|with|are|have|be|at|or|was|so|if|out|not|he|she|they|there|has|do|did|does)\b\s*//g;

    # convert English number-names to numbers
    foreach my $key (keys %nums) { s/\b$key\b/$nums{$key}/eg }

    s/(\d) (?:,|and) (\d)/$1 $2/g;

    s/\b(\d\d) (\d) 100\b/($1 + $2) * 100/eg;
    s/\b(\d{1,2}) 100\b/$1 * 100/eg;

    s/((?:\d+ )*\d+)/sum(split(' ',$1))/eg;

    s/dollar coin/dollar_coin/g;
    s/(quarter|dime|nickel|dollar|coin|bill)s/$1/g;
    s/pennies/penny/g;
    s/(\d+) dollar\b/\$ $1/g;

    # Rules for coin problems

    add_type('dollar_coin',100) if /dollar_coin/;
    add_type('half_dollar',50)  if /half_dollar/;
    add_type('quarter',25)      if /quarter/;
    add_type('dime',10)         if /dime/;
    add_type('nickel',5)        if /nickel/;
    add_type('penny',1)         if /penny/;

    while (/($decimal) (?:times )?as many \$ (\d+) bill as \$ (\d+) bill/g) {
        push @eqns, "n_$2 = $1 * n_$3";
    }

    while (/($decimal) (?:times )?as many (\w+) as (\w+)/g) {
        push @eqns, "n_$2 = $1 * n_$3";
    }

    while (/(\d+) more (\w+) than (\w+)/g) {
        push @eqns, "n_$2 = n_$3 + $1";
    }

    while (/(\d+) less (\w+) than (\w+)/g) {
        push @eqns, "n_$2 = n_$3 - $1";
    }

    if (/same number (\w+) , (\w+) (?:, )?and (\w+)/) {
        push @eqns, "n_$1 = n_$2";
        push @eqns, "n_$2 = n_$3";
    } elsif (/same number (\w+) and (\w+)/) {
        push @eqns, "n_$1 = n_$2";
    }

    if (/(\d+) (?:\w+ )*consists/
          or /(\d+) (?:\w+ )*,?consisting/
          or /total (\d+)(?! ¢)/
          or /(?<!\$ )(\d+) coin/
          or /[^\$] (\d+) bill/
          or /number [^\?\!\.0-9]*(\d+)/) {
        $count = $1;
        push @vars, "count: $count";
    }

    if (/total (?:\w+ )*\$ ($decimal)/
        or /valu(?:e|ing) \$ ($decimal)/
        or /\$ ($decimal) ((bill|coin) )?in/) {
        $total = 100 * $1;
        push @vars, "total: $total";
    }

    if (/total (?:\w+ )*($decimal)/) {
        $total = $1;
        push @vars, "total: $total";
    }

    # Rules for stamp problems
    while (/(\d+). stamp/g) { add_type("$1_stamp", $1) }
    if (/cost (?:\w+ )*\$ ($decimal) (?!each)/) { $total = 100 * $1; push @vars, "total: $total" }

    # Rules for unusual types
    while (/(\w+) cost \$ ($decimal) each/g) { add_type($1, 100 * $2) }
    if (/made \$ ($decimal)/) { $total = 100 * $1; push @vars, "total: $total" }

    # Rules for bill problems
    while (/\$ (\d+) bill/g) { add_type($1, 100 * $1) }
    while (/(\d+) times as many \$ (\d+) bill as \$ (\d+) bill/g) { push @eqns, "n_$2 = $1 * n_$3" }
    while (/(\d+) more \$ (\d+) bill than \$ (\d+) bill/g) { push @eqns, "n_$2 = n_$3 + $1" }
    while (/(\d+) less \$ (\d+) bill than \$ (\d+) bill/g) { push @eqns, "n_$2 = n_$3 - $1" }
    if (/\$ ($decimal) in bill/) { $total = 100 * $1; push @vars, "total: $total" }

    # Rules for greeting card example
    if (/consisting (.+?)costing \$ ($decimal) each and (.+?)costing \$ ($decimal) each/) {
        my ($t1,$v1,$t2,$v2) = ($1,$2,$3,$4);
        $t1 =~ s/ $//; $t1 =~ s/ /_/g; add_type($t1,100*$v1);
        $t2 =~ s/ $//; $t2 =~ s/ /_/g; add_type($t2,100*$v2);
    }

    # Rules for notebook paper example
    if (/sells ([^\$]+)\$ ($decimal) (\w+) and ([^\$]+)\$ ($decimal) (\w+)/) {
        my ($t1,$v1,$u1,$t2,$v2,$u2) = ($1,$2,$3,$4,$5,$6);
        $t1 =~ s/ $//; $t1 =~ s/ /_/g; add_type($t1,100*$v1);
        $t2 =~ s/ $//; $t2 =~ s/ /_/g; add_type($t2,100*$v2);
        if ($u1 eq $u2){
            if (/purchased (\d+) $u1(?:s|es)? (?:\w+ )*and paid \$ ($decimal)/) {
                $count = $1;     push @vars, "count: $count"; 
                $total = 100*$2; push @vars, "total: $total"; 
            }
        }
    }

    # Rules ALL coin problems obey...
    # Rule no 1: Total is sum over all coin types of coin value times coin number
    # i.e., total = dot product of values and quantities
    my $dot = join(' + ', map {"n_$_ * v_$_"} uniq @types);
    if ($total and @types){ push @eqns, "total = $dot" }

    # Rule no 2: Count of all coins is sum of counts of each coin type
    my $trace = join(' + ', map {"n_$_"} uniq @types);
    if ($count and @types) { push @eqns, "count = $trace" }

    printf $results "problem: %s\n", s/\n/ /gr;  # condensed problem statement

    # Prepare MAXIMA batch file
    my $maxima_vars = join("\$\n", uniq @vars);
    my $maxima_eqns = '['. join(', ', @eqns) . ']';
    my $maxima_find = '['. join(', ', map {"n_$_"} @types) . ']';

    if (@eqns and @vars) {
        my $maxima_script = 'tmp/' . time . '_' . rand . '.max';
        open my $script, '>', $maxima_script or die "Couldn't open temporary file: $!\n";
        print $script <<~"END";
            $maxima_vars\$
            solve($maxima_eqns, $maxima_find);
            END
        close $script;
        open my $maxima_output, "/opt/local/bin/maxima -q -b $maxima_script |" or die "Couldn't open maxima: $!\n";
        while($_ = <$maxima_output>) {
            print $results "solution: $1\n" if /\(\%o\d+\)\s+\[\[([^\]]+)\]\]/; # only display solution
        }
        close $maxima_output;
        unlink $maxima_script;

    } else {
        print $results "Couldn't deduce enough information to formulate equations.\n"
    }
    print $results "\n";
}
