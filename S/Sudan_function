#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/Sudan_function
#c# 2022-07-12 >RC
#p# OK
#n# 3 ways of doing the same thing (with totally gratuitous cross-calls)

my @res;

use v5.36;
use experimental 'for_list';

sub F1($n, $x, $y) { $n ? $y ? F1($n-1, F2($n,$x,$y-1), F3($n,$x,$y-1)+$y) : $x : $x+$y }

sub F2($n, $x, $y) { $n == 0 ? $x+$y : $y == 0 ? $x : F2($n-1, F1($n,$x,$y-1), F3($n,$x,$y-1)+$y) }

sub F3($n, $x, $y) {
  return $x + $y if $n == 0;
  return $x      if $y == 0;
  F3($n-1, F1($n, $x, $y-1), F2($n, $x, $y-1) + $y)
}

for my($n,$x,$y) (0,0,0, 1,1,1, 2,1,1, 3,1,1, 2,2,1) {
    push @res, join ' ',F1($n,$x,$y), F2($n,$x,$y), F3($n,$x,$y)
}

say my $result = join "\n", @res;

my $ref = <<'END';
0 0 0
3 3 3
8 8 8
10228 10228 10228
27 27 27
END

use Test::More;
chomp $ref;
is($result, $ref);
done_testing();
