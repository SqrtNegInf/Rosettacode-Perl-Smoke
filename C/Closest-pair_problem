#!/usr/local/bin/perl
#u# http://rosettacode.org/wiki/Closest-pair_problem
#c# 2018-07-23 <>RC, 2022-06-11 >RC
#p# OK
#n# the divide & conquer technique is about 100x faster than the brute-force algorithm

srand 123456;

my $result;

use strict;
use warnings;
use feature 'say';

use POSIX qw(ceil);
use constant Inf => 1e12;
 
sub dist {
    my ($a, $b) = @_;
    return sqrt(($a->[0] - $b->[0])**2 +
                ($a->[1] - $b->[1])**2)
}
 
sub closest_pair_simple {
    my @arr = @{ shift @_ };
    my ( $a, $b, $d ) = ( $arr[0], $arr[1], dist($arr[0], $arr[1]) );
    while( @arr ) {
	    my $p = pop @arr;
	    foreach my $l (@arr) {
	        my $t = dist($p, $l);
	        ($a, $b, $d) = ($p, $l, $t) if $t < $d;	    
	    }
    }
    $a, $b, $d
}
 
sub closest_pair {
    my @r = @{ shift @_ };
    my @ax = sort { $a->[0] <=> $b->[0] } @r;
    my @ay = sort { $a->[1] <=> $b->[1] } @r;
    closest_pair_real(\@ax, \@ay)
}
 
sub closest_pair_real {
    my ($rx, $ry) = @_;
    my(@yR, @yL);
    my @xP = @$rx;
    my @yP = @$ry;
    my $N = @xP;
    return closest_pair_simple($rx) if scalar(@xP) <= 3;
 
    my $inf = 1e600;
    my $midx = ceil($N/2)-1;
    my @PL = @xP[      0 .. $midx];
    my @PR = @xP[$midx+1 .. $N-1];
    my $xm = ${$xP[$midx]}[0];
 
    foreach my $p (@yP) {
	    if ( ${$p}[0] <= $xm ) {
	        push @yR, $p;
	    } else {
	        push @yL, $p;
	    }
    }
 
    my ($al, $bl, $dL) = closest_pair_real(\@PL, \@yR);
    my ($ar, $br, $dR) = closest_pair_real(\@PR, \@yL);
	my ( $w1, $w2, $closest ) = $dR > $dL ? ($al, $bl, $dL) : ($ar, $br, $dR);
 
    my @yS;
    foreach my $p (@yP) {
	    push @yS, $p if abs($xm - ${$p}[0]) < $closest;
    }
 
	foreach my $i (0 .. $#yS-1) {
	    my $k = $i + 1;
	    while ( $k <= $#yS and (${$yS[$k]}[1] - ${$yS[$i]}[1]) < $closest) {
		    my $d = dist($yS[$k], $yS[$i]);
		    ($w1, $w2, $closest) = ($yS[$k], $yS[$i], $d) if $d < $closest;
		    $k++;
	    }
 
	}
	$w1, $w2, $closest
}
 
my @points;
foreach my $i (1..5000) {
    push @points, [rand(20)-10, rand(20)-10];
}
 
 
my($a, $b, $d) = closest_pair_simple(\@points);
$result .= "$d\n";
 
my($a1, $b1, $d1) = closest_pair(\@points);
$result .= "$d1\n";

say $result; 

my $ref = <<'EOD';
0.00259321833704879
0.00259321833704879
EOD

use Test::More;
is ($result, $ref);
done_testing();
